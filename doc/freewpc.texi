\input texinfo
@c %**start of header
@setfilename freewpc.info
@settitle The FreeWPC Manual
@setchapternewpage odd
@c %**end of header

@set VERSION 0.90
@set COPYRIGHT 2006-2009

@titlepage
@title The FreeWPC Manual
@author Brian Dominy

@sp 10
@center @titlefont{}

@page
@vskip 0pt plus 1filll
Copyright @copyright{} @value{COPYRIGHT} by Brian Dominy.
@end titlepage

@contents

@ifnottex
@node Top
@top Introduction

This is the manual for @dfn{FreeWPC}, a free platform for developing replacement
game ROMs for Bally/Williams pinball machines based on the WPC
(Williams Pinball Controller) chip.  FreeWPC provides the foundation for building
new ROMs with custom game rules.  This document describes version
@value{VERSION} of the software.

FreeWPC is developed by Brian Dominy (@email{brian@@oddchange.com}) and is licensed
under the GNU General Public License version 2 or later.  The latest version of
the software can be obtained at @url{http://www.oddchange.com/freewpc}.
Developers should be familiar
with basic embedded systems programming concepts and the C programming
language.  Familiarity with 6809 assembler is highly recommended.
Also, knowledge of WPC pinball machines is very helpful.

@end ifnottex

@menu
* Overview::                A basic description of what FreeWPC is.
* Installation::            How to obtain and install the software.
* Compiling::               How to recompile the code yourself.
* The WPC Hardware::        A primer on the hardware architecture.
* Software Environment::    The basic software model.
* Hardware APIs::           How to control the hardware.
* Effects::                 How to choreograph lights, sounds, and graphics.
* Ball Tracking::           How the locations of the pinballs are monitored.
* Test Mode::               Differences in the service menu.
* Common Pinball Library::  Other common functions that are implemented.
* Fonts and Graphics::      More info on the display APIs.
* Native Mode::             Running the software directly on your PC.
* Debugging::               How to debug problems.
* The Machine Definition::  How to define a new machine.
* System Events::           A list of the predefined callback functions.
* Build Tools::             Other programs used during the build process.
* Dot-Matrix Performance::  Thoughts on optimization of the display.
* Historical Notes::        Random observations from past experience.
@end menu

@ignore
* Frame Rate::
* Simulating Color::
* 6809 Instruction Set::
* The Fastest Copy in Town::
* Bit Alignment::
* Compression Techniques::
* Binary Packages::
* Source Code Packages::
* Directory Layout::
* Configuration::
* Making the ROM::

@menu
* Switches::
* Lamps::
* Power Drivers::
* Zerocross Detector::
* Dot-Matrix Display (DMD)::
* Sound Board::
* Triacs and General Illumination::
* Real-Time Clock::
* High Precision Timer::
* Miscellaneous::
* Debug Port::
* Paging and Locking::
* Bit Shifting::
@end menu

@menu
* Device Status::
* Global Status::
* Events::
* The Trough Device::
@end menu

* Adjustments::
* Audits::
* Tests::
* Development::

* Coins and Pricing::
* Ball Devices::
* Extra Balls::
* High Scores::
* Enter Initials::
* Tournament Mode::
* Ball Search::
* Knocker Driver::
* PIC Driver::
* Player Local Data::
* Adjustments::
* Audits::
* Scoring::

* Compression::
* Using TrueType Fonts::
* Frame List::

* @command{wpcdebug} and @command{PinMAME}::
* @command{gdb}::
* @command{exec09}::
* @command{csum} : ROM Checksum Tool::
* @command{srec2bin} : S-Record Converter::
* @command{sched} : Static Scheduler::
* @command{fontgen2} : TrueType Font Generator::

* Overview::
* CPU Board::
* Power Driver Board::
* Sound Board::
* Fliptronic Board::
* Auxiliary Driver Board::
* Dot Matrix Controller Board::
* Memory Map::

* Syntax::
* Fixed Objects::
* Variable Objects::
* Directives::
* Global Configuration::
* Section Summary::
* How genmachine works::
@end ignore

@node Overview
@chapter Overview

FreeWPC is a toolkit for building new software for Williams WPC pinball machines.
WPC is the hardware platform that was used in all games from 1990-1999, starting with
@samp{Funhouse} and ending with @samp{Cactus Canyon}.

This document provides an overview of the FreeWPC architecture for
developers who wish to understand how the system works.
The details provided here reflect the status of the latest development
branch.  FreeWPC is constantly evolving and the information here is
subject to change.

FreeWPC only replaces your game ROM (the U6 chip on the CPU board), which contains all
of the game code and dot matrix text/graphics.  In particular, sounds and
music are NOT included in this device, so FreeWPC games use the
same sounds as the real machines.

FreeWPC is 100% Williams-free code, written from scratch.  It is not a hack on existing
ROMs and does not contain any software extracted from real games.
Most of the code is written mostly in the C programming language.  (Actual WPC games
were programmed in assembly language).  FreeWPC uses the freely available GCC6809 C
compiler.  There are some assembly language routines for really low-level, or high
performance parts of the program.

All generations of WPC are supported.  FreeWPC is also architected into a number of
distinct layers which makes it highly portable to other
types of pinball machines than just WPC games, including new custom hardware.  The
@emph{platform} files describe the circuit boards.  The @emph{CPU} files are specific to
the microprocessor, and can be shared between platforms (WPC and WhiteStar both use
a 6809).  The @emph{machine} files are unique to a particular game.

Development requires a UNIX-like environment, such as Linux or Cygwin for Microsoft Windows
users.  Many common UNIX tools like @command{bc} and @command{perl} are required.

In addition to building ROMs, the toolkit supports @dfn{native mode compilation}, which
builds an executable that can be run directly on your development machine.  This lets you
test and debug the software without requiring a real machine or even an emulator.  Basically,
native mode replaces the lowest level of hardware access with builtin emulation.  Native
mode currently uses the @command{ncurses} terminal library for visualizing the state of the game.

@node Installation
@chapter Installation

This chapter explains how to install the software.

FreeWPC is mainly a toolkit, and thus is provided in source code format.
However, periodically binary ROMs are compiled and published as well.
If you are not a developer, but would like to experiment with FreeWPC,
you can just download the binary packages and install them in your
machine or in your emulator.

If you are a developer and want to write your own game code, for one
of the existing games that FreeWPC has been ported to or for a brand
new game, you need a source code package.

If you just want to browse the source code, you can view it online
at the GitHub repository.

@section Binary Packages

Binary packages are available as @file{.zip} files, which contain
@file{.rom} files.  These ROMs replace the game ROM only (the U6 chip
on the CPU board).  If you want to test in a real machine, you need
to burn a real EPROM from this file.

If you want to test under PinMAME, you need to copy the ROM file into
your PinMAME @file{roms} directory; where this is
depends on how you installed PinMAME.  These directories typically contain
@file{.zip} files of both the game ROM and sound ROMs together.
You'll need to unzip the original file, replace the game ROM, then zip it back.
Make sure to save your original
game ROM file for when you want to revert back to the Williams code.

@section Source Code Packages

The following is a partial list of other programs which are used during the
build process: gcc6809, dd, bc, zip, unzip, bash, Perl.

@section Directory Layout

The FreeWPC source code tree is organized into the following directories:

@table @file

@item kernel/

The core pinball APIs.  All of these functions are kept in the fixed
region of ROM and can be called at any time.

@item common/

Secondary pinball APIs, also called the @dfn{Common Pinball Library}.
These functions are not in fixed ROM and require bank switching to call.

@item machine/@var{machine}/

The machine-specific files.

@item platform/@var{platform}/

The platform-specific files.  These are mostly used during initialization.

@item cpu/@var{cpu}/

The CPU-specific files.  These are mostly assembly language files.

@item fonts/

The standard font files.

@item drivers/

Driver templates for things like jets, slings, kickbacks, etc.

@item include/

All of the include files are kept in here or one of its subdirectories.

@end table

@node Compiling
@chapter Compiling

@section Configuration

FreeWPC can be compiled in many different ways with lots of optional features.
You cannot just type @command{make} at the top of the directory tree without
first specifying what you want to build.  This is done by creating a file
named @file{.config}.  The file @file{config.example} is provided as an
example of the kinds of things that can be tuned.

@file{.config} is written in standard Makefile syntax.  (The top-level
Makefile includes this file.)  You set various options by writing
variable assignments, such as:

@example
MACHINE := wcs
@end example

A list of all of the options is given later in an appendix.
TBD - move the appendix information here.

You must specify at least a @var{MACHINE}.  All other configuration
variables are optional; suitable defaults will be used.

@section Making the ROM

After configuring, type @command{make}.  This will build a ROM and optionally
install it into your PinMAME ROM directory if you have said where that is.

The exact commands are not printed, but you can force the details to be
shown by setting the environment variable @var{Q} to the empty string, like
this:

@example
make Q=""
@end example

The build procedure is complicated, but it can be broken down into the
following steps:

@enumerate

@item Create Blank File

If the size of the ROM is larger than the number of pages that
the compiler generates, then the final ROM image must be
padded with blank sections.  The @command{dd} command is used
to generate a file named @file{blank@var{xxx}.bin}, where @var{xxx}
is the size of the file in kilobytes (KB).  This file
is later concatenated with the linker output to produce
a final ROM of the required size.

@item Create Linker Command Files

The linker is invoked several times, once per page or
bank of ROM.  Different options are passed each time
to place the correct object files into that section, and
to resolve references correctly.  All of these options
are written to linker command files, which have the .lnk
extension and are placed in the @file{build} directory.
They are an essentially a list of command-line options to the linker,
but placed into a file because of the huge number of them.

@item Setting the Machine Symbolic Links

The symbol link @file{mach} is set to point to the correct
machine code directory, based on the value of the MACHINE
make variable.  Likewise, @file{include/mach} is pointed to the
machine includes.

@item Generating Defines

Some #defines are generated automatically by scanning the
code for their uses.  These include files begin with the prefix
@command{gendefine} and are created by a script also named
@command{gendefine} in the @file{tools} directory.

At present this is only used to autogenerate the task group IDs.

@item Generating Callsets

Callsets are a mechanism for implementing a simple
event subscription/invocation mechanism that is fully
described at compile-time.  Event handling code is
emitted in a C file named @file{callset.c}.

@item Compiling and Assembling Source Code

Source code is compiled using the GCC6809 compiler.
The compiler generates assembler code with the @file{.s}
extension.  These files are then assembled using the
asxxxx asembler tools into object files with the @file{.o}
extension.

@item Compiling Page Headers

Because the linker requires each section to contain at
least one object file, a dummy file is assembly per
section to ensure that this doesn't happen.  The page
header is 1 byte long and contains the page number.

@item Linking Pages

The aslink utility is used to create one S-record file,
with the @file{.s19} extension, for each page of ROM.

@item Converting Pages to Binary

The @file{tools/srec2bin} utility included with FreeWPC
is run to convert the S-records into raw binary files.

@item Concatenating Pages

The binary files are concatenated, along with any blank
files, to form the final ROM image.

@end enumerate

@section Build Results

If successful, @file{build/@var{var}.rom} will contain the ready-to-burn ROM image.  @var{var} is
a string composed of the machine's short name and the version number.

Warnings and errors during the build are display on the console as they
occur; they are also log to a file named @file{err}.

In native mode, instead of a ROM, a file named @file{freewpc_@var{var}} is placed at the root
of the tree.

@c ======================================================
@node The WPC Hardware
@chapter The WPC Hardware

@include hardware.texi

@c ======================================================
@node Software Environment
@chapter Software Environment

FreeWPC is a standalone operating system environment.  It does not use any
existing OS and has its own multitasker, memory manager, etc.  This chapter
describes the key features of the OS.

@menu
* Multitasking::           The normal process model
* Real-Time Processing::   How to schedule realtime tasks
* Memory Allocation::      How to allocate and initialize variables
* Event Handling::         Throwing and catching events
* Template Drivers::       Writing reusable software blocks
* Fault Detection::        Handling serious errors
* Timers::                 The many implementations of timers to choose from
@end menu

@node Multitasking
@section Multitasking

FreeWPC implements a runtime, round-robin, non-preemptive task scheduler.
The system manages multiple tasks, each of which has its own call stack.  You
can create a new task when you want to run some code in parallel with the current
thread of execution.  The current task has complete control of the CPU and will
continue to run until it explicit exits or sleeps (waiting for a certain amount
of time).  The minimum sleep time is defined by IRQS_PER_TICK and is currently 16ms.

(Contrast this with desktop operating systems, which use timeslicing and preemption to
allow multiple threads to run in parallel.  There, the OS switches between the tasks.
In FreeWPC task switches only happen explicitly; this provides for more deterministic
behavior, it requires less overhead, and it eliminates the need for mutexes (locks)
between two tasks.

If a task does not give up control, either by sleeping, exiting, or yielding
after a certain amount of time, the fatal error @code{ERR_FCFS_LOCKUP} will be asserted.

Each task is identified by a @dfn{process ID}, or @dfn{pid}.  The PID for a task
is assigned by the system when it is created.  A task also has a @dfn{group ID},
or @dfn{gid}.  The GID is assigned by the programmer, and multiple tasks can share
the same GID.  GIDs allow you to control a group of related tasks, or to
refer to a task using a compile-time ID as opposed to a run-time ID.

In native mode, the multitasking APIs are implemented using the GNU
Pth library.  A good description of this library can be found at
@url{http://www.gnu.org/software/pth/}.  Note this is not the same
as @command{pthreads}, which is the predominant @emph{preemptive}
threading library.

When there are no tasks ready to run because all are blocked, the system is @dfn{idle}.
During idle time, the CPU calls some @dfn{idle functions} which perform
low-priority maintenance.  You can register an idle function at various
rates: either every 100ms, 1 second, or 10 seconds.  Idle functions are
preferable to realtime functions for periodic processing if the scheduling
requirements are not strict.  For example, a 1 second handler may not be
called again for 1.5 seconds, because the system is busy running other
tasks.  If that happens, the next time it will be called just 500ms
later; the idle scheduler will realize that it is behind and try to
catch up.

Idle functions do not run in a task context, so like interrupt handlers,
they cannot sleep.  You also cannot dynamically register or deregister
idle handlers at runtime.

@node Real-Time Processing
@section Real-Time Processing

The multitasking APIs are flexible but do not guarantee realtime response, since
any task may run for a long time.  Processing that needs to occur at a strict interval
is done by @dfn{real time tasks}, sometimes abbreviated in the code as @dfn{RTTs}.

Real-time tasks are scheduled at @emph{compile-time}.  When you write an RTT, you
must also add an entry to the @dfn{schedule file}, either @file{kernel/system.sched}
for the core parts of the system, or @file{machine/@var{machine}/@var{machine}.sched}
for the game-specific RTTs.  Each entry in the schedule file gives the rate at which
you want your function to be run, for example, once every 8ms.  You can schedule
to run as frequently as once every 1ms, but you should only schedule as often as
you really need it, otherwise the CPU will have little time to do anything else!

Real-time functions run at interrupt (IRQ) level.  They will interrupt anything
else that is running at non-real-time priority.  They cannot sleep.

A scheduler, @command{gensched}, processes these files at compile-time and generates
the IRQ handler which calls all of the RTTs at the correct frequency.  The output
can be seen in @file{build/sched_irq.c}.

Optimizing the realtime tasks is key to an efficient system.  To date,
about 30% of the 6809 is spent in realtime tasks; the actual value
depends on the machine and the number of device drivers needed.

In native mode, realtime functions are run inside an ordinary task.  They
cannot run exactly at the desired rate, but the emulation does its best.  If the
"IRQ task" sees that 30ms has gone by, then it will call the top-level IRQ handler 30
times.

To summarize, the priority of functions from highest to lowest is:

@table @bullet
@item Realtime tasks
@item Normal tasks
@item Idle functions
@end table

@node Memory Allocation
@section Memory Allocation

FreeWPC does not use dynamic (heap) memory allocation at all.  All variables are either
global or on the stack.

Global variables cannot be statically initialized.  Variables should be initialized
explicitly inside a C function.

Global variables can be divided into a number of categories, depending on their
usage.  Normal globals are always in scope and behave as you would expect.  Additionally,
you can tag a global with one of the following attributes:

@table @code

@item __fastram__

Used for variables that are used frequently.  GCC6809 will generate faster
code when accessing these.  However, you are limited to about 250 bytes of
fastram variables total.

@item __permanent__

Used for variables that should be persistent across reboots.  These variables
should be initialized inside of a @code{factory_reset} event, because factory
reset should restore everything to a sane state.

@item __nvram__

Like __permanent__, but for variables that are also write-protected by default.
To modify such a variable, you must first issue an @code{unlock()} call, and
also issue a @code{lock()} call when you are done.  This helps to ensure that
certain critical variables are not accidentally corrupted.

Adjustments and audits kept in NVRAM are managed via special APIs which
do the locking/unlocking for you.

This feature works even in native mode; the __nvram__ variables are saved
to a file when you exit the program.

@item __local__

Used for variables that are maintained separately for different players
in a multiplayer game.  The system software will transparently reload
these variables with the correct values whenever the player up changes.
These variables should be initialized inside of an @code{add_player} event.

@end table

@node Event Handling
@section Event Handling

FreeWPC is mostly an @dfn{event-driven} system, which only acts when there are new
inputs to the system.  This section describes the basic interface to the
application layer software, and then explains how that is implemented internally.

When any module wants to be notified when a particular event occurs, it declares
an event catcher function, using the CALLSET_ENTRY macro.  Here is an example:

@example
CALLSET_ENTRY (strobe_multiball, sw_forcefield_target)
@{
	...
@}
@end example

This declares a new catcher for the module named @code{strobe_multiball},
which is to be called whenever the event @code{sw_forcefield_target} occurs.

The name of the module is arbitrary, but the convention is to use the name
of the source code file or something similar.  If you need to write two different
handlers in the same source file for the same event, they need to have different
module names.

The event name must exactly match the name used when it was generated.
There is a list of predefined system events which are often caught (@pxref{System Events}).
Switch names can also be used as events (e.g. sw_free_kick_target).  Normally a switch
event is generated on an @emph{inactive-to-active transition}; you can cause an event
on any transition by declaring the switch as @samp{edge}.
Ball devices also generate events for several reasons (@pxref{Ball Tracking}).

If there are multiple catchers for the same event, then all of them
will be invoked, in some random order.  For example, another mode might
also make use of the same target:

@example
CALLSET_ENTRY (mode_start, sw_forcefield_target)
@{
	...
@}
@end example

Then both of these handlers would be called when the switch is closed.

To generate an event, use the @code{callset_invoke()} API, passing
it the name of the event.  You can create your own events for any
purpose; event names do not need to be declared.  Such events are
as full-featured as system-defined events.  When defining custom events
in a game, it is customary to prefix the event name with the short
name of the game (e.g. @samp{tz}).

Event catchers are allowed to throw new events.  This will result
in nested function calls.

@subsection Boolean Events

Most event handlers do not return a value.  However, in some cases
it is desirable to stop calling event handlers once the event has
been @emph{claimed}.  You can do this with boolean events.

To throw a boolean event, use @code{callset_invoke_boolean()}.  This
returns TRUE if all of the event handlers return TRUE; else it
returns FALSE.

The event handlers are declared using @code{CALLSET_BOOL_ENTRY} instead
of @code{CALLSET_ENTRY}, and they must return either TRUE or FALSE.

The invocation of boolean handlers will immediately stop if one of them
returns FALSE (so-called @dfn{short-circuit evaluation}).

@subsection Handlers in Banked Pages

Because handlers are invoked via function calls, if the handlers are
in a banked section of ROM, care must be taken to ensure that the
proper far call is made to it.  In most cases, this is autodetected
based on the directory in which the source file is located:

@itemize @bullet
@item Files in kernel are assumed to be in fixed ROM.
@item Files in @file{common} are assumed to be linked into COMMON_PAGE.
@item Files in @file{machine} are assumed to be linked into MACHINE_PAGE.
@end itemize

You can explicitly declare the section in the source file by
adding a comment like this:

@example
/* CALLSET_SECTION (@var{module-name}, @var{section-name}) */
@end example

This is only needed if the module uses event handlers, and the section can't
be determined automatically as explained above.  @var{section-name}
would be something like @code{__common__} or @code{__machine__}.  The
@var{module-name} must match all of the module names used in the
@code{CALLSET_ENTRY} definitions within it.

@subsection Debugging Event Handlers

@command{gencallset} has a @option{-d} option which emits @code{dbprintf()} statements
as each event handler is called.  It is extremely verbose, but it can be used to
debug when you don't know where to start when something isn't working.

You can enable it by setting @command{CALLSET_FLAGS := -d} in @file{.config}.

@subsection How Event Handlers Are Implemented

When you write a @code{CALLSET_ENTRY}, the module name and event name are
concatenated to form the name of a function, separated by an underscore.

When you write a @code{callset_invoke}, it calls a function named @code{callset_@var{event}}.
@command{gencallset} scans all of the source code and creates these functions; you can
see the output in @file{build/callset.c}.  So there is no queueing, memory allocation, or
anything complicated --- these are just ordinary function calls.  The trick is to do all
of the work at compile-time.

@node Template Drivers
@section Template Drivers

A @dfn{template} is a crude implementation of a reusable code block, similar in
purpose to C++ templates but much more limited.  Were FreeWPC written in C++,
regular templates would have been used here.

Templates end in @file{.ct} (for C template) and are always kept in the
@file{drivers/} directory.  A template file is @dfn{instantiated} via
commands in the machine description.  The script @command{ctemp} converts
a template to one or more .c or .h files, which are then compiled normally.
Thus, templates can contain RTTs or event handlers just like any other file.

@subsection Template Syntax

A template contains ordinary C code, plus special @dfn{template directives}.
These always begin with two at-signs (@@@@).  The list of valid directives,
in the order that they are normally used, is listed below:

@table @code

@item @@@@class

Gives the name of the template; usually this is related to the filename.

@item @@@@parameter @var{name}

Declares a template parameter.  The value is substituted during instantiation.

@item @@@@file

Sets the current output filename.
A template can generate any number of output files.
You can switch between the different output files with this directive.

@item @@@@

A template comment.  Used to insert a comment line that is not placed
into the current output file.

@end table

Within the C code, you use single-at (@@) references to substitute the
values of template variables into the text.  For example,

@example
@@@@class xyz
int @@class_variable
@end example

would be translated into the following plain C code:

@example
int xyz_variable
@end example

Notice that template variables cannot contain underscores.

Anything template parameter defined with @@@@parameter can be
substituted this way.
Also, the following variables are predefined by the code generator:

@table @code

@item @@class

The name of the template, as given in a @@@@class directive.

@item @@self

The name of the instance.  If a template is instantiated multiple times,
each should have a different name.  For example, the @samp{sling} class
might have instances named @samp{left_sling} and @samp{right_sling}.

@item @@instance

Like @@self, but a zero-based ID.  These are assigned by the code
generator during instantiation.

@end table

@node Fault Detection
@section Fault Detection

Fatal errors when detected will cause the system to reboot.  The system
API @code{fatal()} can be used to cause a fatal error at any time.
A list of the error codes is kept in @file{include/sys/errno.h}.

There is also the @code{nonfatal()} API
for logging errors which will not cause a reset.  These are audited
and when @code{DEBUGGER} is defined, it will display a brief message on the DMD.

The core operating system code throws fatal errors in several key
circumstances:

@itemize @bullet
@item When task scheduling locks up
Because tasks continue to run until they give up control, a "hung" task
will hang the entire system.  At realtime level, this can be detected
by seeing that the current task has not changed for a certain period of
time.  This works because realtime uses interrupts.
@item When we cannot create a new task
The number of tasks is bounded, to prevent runaway task creation/
memory allocation.  Many other subsystems do the same whenever a limit
is reached.
@item When an NMI or other unexpected interrupt occurs
@item When the non-volatile memory is found unlocked.  This is almost
always because someone called @code{pinio_nvram_unlock()} and forgot
to call @code{pinio_nvram_lock()} afterwards.
@item Certain illegal function calls are made, such as trying to sleep
from outside task context.
@end itemize

@node Timers
@section Timers

There are a number of ways to implement timers.  One way is just to use
@code{task_sleep} from within task context.  You can also use the
@code{timer_@var{xxx}} APIs, which do things internally beneath a more
standard API.

Sometimes you may want a timer but without the overhead of a separate task.
Then use the @code{free_timer_@var{xxx}} functions.  @dfn{Free timers}
are small counters that are updated in realtime context.  They do not
support pausing (hence, the name) but can be started/stopping.  The set
of all free timers must be declared in advance in the machine
configuration file.

Free timers are useful for the case when you need to run a timer, and
no code needs to be executed when the timer expires.  You can always
write code to query the timer value, but if it expires to zero, then
nothing special happens.  One common use is for detecting certain
playfield shots when a series of switches needs to activate within
a certain amount of time, say 1 second apart.

@c ======================================================
@node Hardware APIs
@chapter Hardware APIs

The kernel provides a common set of hardware access functions
that work across all of the different variations of the WPC
architecture.

There are basically two types of APIs.  The low-level APIs
access the hardware directly.  These APIs all begin with @code{pinio}.
They could be ported to any new pinball platform.  These are
normally called only from realtime tasks (driver space, if you will).
Every supported platform (WPC, Whitestar) needs to define these functions.
See @file{include/platform/wpc.h}.

The high-level APIs are invoked from the application layer (user space).  They
are typically more user friendly, and don't actually talk directly to the
hardware, but rather interface with a @dfn{device driver}, which abstracts the
actual hardware.

For example, an API to check the status of a particular switch is a
high-level API.
The low-level API deals with the fact that switches are in a matrix, the column
strobing, etc.  It is the switch driver which glues the two layers together.

@section Switches

The switch matrix driver polls the hardware every 2ms and constantly updates
its view of all of the switches in memory.  The user APIs can then query this
data.

Less frequently, the driver will also detect when switches have
@emph{changed state}, and may invoke event handlers for these.

Each switch entry in the machine configuration file can declare the following
flags per switch, which alter the way that the switching code will manage
it:

@itemize @code

@item SW_OPTICAL

Says that this is an optical switch, which is active low rather than
active high.

@item SW_EDGE

Says that the switch event should be thrown when it goes inactive, in
addition to when it goes active.  Handlers for edge switches generally
need to check which type of transition just happened, by calling
@code{switch_poll_logical}.

All counting switches in a ball container must be edge switches, so that the
device count can be updated correctly.  The shooter switch is also usually
declared edge.

@item SW_IN_GAME

Says that this switch should only be serviced during a game.

@item SW_PLAYFIELD

Says that this switch is on the playfield, and can be activated by a ball,
as opposed to cabinet buttons, motor optos, etc.  A playfield switch
event will normally set the valid playfield flag.

@item SW_NOVALID

Set for a SW_PLAYFIELD switch for which the valid playfield flag should
not automatically be set.  This is used for switches that might
unreasonably activate not due to a ball, such as a misaligned jet bumper
that continually fires.

These are the switches that you can trigger at ball start and drain, and
still get the ball back.

@item SW_IN_TEST

Says that this switch handler should also be called in test mode.
Normally in test mode handlers are not called, but important switches
like cabinet buttons require this.  If this flag is set, handlers will
need to test the @code{in_test} variable to see if we are in test mode,
and act accordingly.

@end itemize

The driver also performs debouncing, so that rapid open and close
are not considered.

Switch entries can also declare an associated playfield lamp; when
this is done, valid activations of the switch will cause a brief
pulse of the lamp, using an internal lamp effect.

@table @code

@item pinio_write_switch_column

Set the current switch matrix column.

@item pinio_read_switch_rows

Read all of the switches on the currently selected column.

@item pinio_read_dedicated_switches

Read all of the dedicated switches.

@item pinio_read_flippers

Read all of the Fliptronic switches.

@item pinio_read_flipper_buttons

Read all of the Fliptronic button switches.

@item pinio_read_flipper_eos

Read all or some of the flipper switches.

@item pinio_read_locale

Read the locale indicator (jumpers or DIP switches).

@item switch_poll

Read the stable, physical state of a switch.  Returns 1 if it has
a high level, or 0 for a low level.

@item switch_poll_logical

Read the stable, logical state of a switch.  Returns 1 if it is
active, or 0 for inactive.  This is the same as @code{switch_poll}
but it inverts its result for optos.

@end table

@section Lamps

Each physical lamp is controlled by several flags.  The lamp driver
combines the values of all these flags to decide at any time whether
a lamp should be on or off.

@table @asis
@item On/Off
Controls the steady on/off state of the lamp.
@item Flashing
When set, overrides the steady state and causes the lamp to flash.
@item Effect 1 Allocated/Value
When the allocated flag is set, overrides the steady/flashing state
by the value of value flag.
@item Effect 2 Allocated/Value
Same, except overrides the Effect 1 flags as well.
@end table

The steady and flashing flags are per-player, and are automatically
switched out in a multiplayer game.

@table @code
@item lamp_on
Turns on a lamp.
@item lamp_off
Turns off a lamp.
@item lamp_test
Tests whether a lamp is on/off.
@item lamp_toggle
Toggles a lamp's on/off state.
@item lamp_flash_on
Enable lamp flashing.
@item lamp_flash_off
Disable lamp flashing.
@item lamp_flash_toggle
Toggle lamp flashing.
@item lamp_tristate_on
Ensure the lamp is steady.
@item lamp_tristate_off
Ensure the lamp is off.
@item lamp_tristate_flash
Ensure the lamp is flashing.
@item pinio_write_lamp_strobe
Set the current lamp matrix strobe.
@item pinio_write_lamp_data
Write lamp row data for the currently selected column.
@end table

@section Power Drivers

Solenoid outputs are not matrixed; they are individually writable at all times.
A '1' value means to turn it on, and '0' to turn it off.

@table @code

@item pinio_write_solenoid_set (@var{bank}, @var{value})

Refresh a set of 8 solenoids.

@end table

@subsection Pulse Drivers

@dfn{Pulse drivers} are operated infrequently, and only for short
durations at a time.  The system prevents multiple pulses from
occurring simultaneously and will queue and stage them.  These
are normally used for kickers, poppers, etc.

@table @code

@item sol_request

Pulse a solenoid, and wait for it to be fired.  (A request may
be delayed for a number of reasons.)

@item sol_request_async

Pulse a solenoid, but don't wait for it to be fired.

@end table

@subsection Continuous Drivers

@dfn{Continuous drivers} can run for longer periods of times.
They are allowed to run in parallel with anything else.  They
will frequently use @dfn{duty cycling} to avoid keeping the
coil 100% active for too long, and thus they often require
realtime processing to switch reliably.

These types of drivers are all implemented using templates.

@c include coil-drivers.txt

@subsection Flashers

The flashlamp APIs are similar to the solenoid APIs,
except that they are momentary.  A flashlamp is
pulsed briefly, after which it is turned off.

@table @code

@item flasher_pulse

Pulse a flashlamp for a nominal period of time.

@end table

@section Zerocross Detector

The zero cross driver increments a counter every 1ms, and clears it
whenever zero cross is asserted.  With knowledge of the AC cycle
length, this allows a relatively good reconstruction of the waveform.
For example, in the US zero cross should occur about once every 8ms.
When the counter is at 4, the AC should be at its peak voltage.
Outside the US, this would occur when the counter is at 5.

Note that the AC waveform is not synchronized to the oscillator that
generates IRQ, so a perfect reconstruction is not possible.

@table @code

@item pinio_read_ac_zerocross

Return nonzero if currently at a zerocross point.

@end table

@section Dot-Matrix Display (DMD)

To write to the DMD, you must go through the following steps:

@itemize @bullet

@item Allocate a new display page.
The new page may contain old, stale data in it; it is not necessarily initialized.

@item Map the page into memory.
At most two pages can be seen by the CPU at a time on the 6809.  These are
called the @dfn{low page} and @dfn{high page}.  Generally, anything simple uses
only the low page.  In the APIs below, the term @var{map} refers to either
@emph{low} or @emph{high}.

@item Initialize the page if necessary.
If you are writing text only, you would want to clear the page first.  If you
are filling the page with a full-size image, that is not necessary.

@item Render text and graphics on the page.

@item Optionally, create a composite of several pages together
For example, overlaying text onto background art.

@item Show the page.
Until the page is shown, it is not visible.  This prevents each step of the
rendering process from being seen, which is not visually appealing.

@end itemize

There are APIs to do all of these things individually; there are also some APIs
that combine some of these steps to make it easier.

@table @code
@item dmd_alloc_@var{map}
Allocate and map a single page into either the low or high area.
@item dmd_alloc_low_high
Allocate and map two pages at once.  The pages will always have consecutive
page numbers (N and N+1).
@item wpc_dmd_set_high_page
@item wpc_dmd_get_high_page
@item wpc_dmd_set_low_page
@item wpc_dmd_get_low_page
@item dmd_flip_low_high
Flip the mappings, so that the low page appears in the high region, and vice
versa.
@item dmd_clean_page_@var{map}
Zero a display page.
@item dmd_copy_page
@item dmd_and_page
@item dmd_or_page
@item dmd_xor_page
@item dmd_shadow_copy
@item dmd_text_raise
@item dmd_show_@var{map}
Show a single display page as a 1-color image.
@item dmd_show_other
@item dmd_show2
Show both display pages together as a 3-color image.
@item font_render_string
@item font_render_string_center
@item font_render_string_right
@item bmp_draw
Draw an arbitrary sized bitmap onto the low page.
@item frame_draw
Draw a full-size, 3-color frame onto the low and high pages.
@end table

There are many more APIs for drawing text and graphics.

@section Sound Board

Two flavors of sound board are supported: WPC, and DCS.
The same APIs are used in either case.

@table @code
@item pinio_reset_sound
Reset the sound board.
@item pinio_write_sound
Write an 8-bit code to the sound board.
@item pinio_sound_ready_p
Return true if the sound board has an 8-bit waiting to be read.
@item pinio_read_sound
Read an 8-bit code from the sound board.
@item sound_send
Sends a command to the sound board.  The command may be 8-bit or 16-bit.
@end table

@section Triacs and General Illumination

@table @code
@item pinio_write_triac
@item triac_on
Turns on one or more triacs.
@item gi_dim
Enables a dim general illumination string.
@item triac_off
Turns off one or more triacs.
@end table

@section Real-Time Clock

The WPC ASIC contains an internal realtime clock.
The battery power keeps the RTC running even when the machine is turned off.

The chip provides three registers for counting minutes, hours, and days.
FreeWPC keeps the calendar time in persistent memory.
About once per minute, it polls the RTC and updates the calendar time to reflect
any changes.

@table @code
@item rtc_read
@item rtc_write
@end table

@section High Precision Timer

@table @code
@item pinio_read_timer
@item pinio_write_timer
@end table

@section Miscellaneous

@table @code

@item pinio_watchdog_reset

Reset the hardware watchdog timer.

@item pinio_active_led_toggle

Toggle the diagnostic LED.

@end table

@section Debug Port

@section Paging and Locking

@table @code
@item pinio_set_bank
Writes a bank-switching register.
@item pinio_get_bank
Reads a bank-switching register.
@end table

@section Bit Shifting

The ASIC has a builtin shifter that can do some bitwise math faster
than native 6809 code.

@command{gcc6809} has an option @option{-mwpc} which
enables emitting instructions for the WPC platform.
In some cases, the hardware shifter will be used
automatically.  Note that gcc is unaware of the
threading/interrupt model, so access to the shifter
is not protected.  In the current implementation,
the shifter is not used from the IRQ, and since
tasks are nonpreemptive, that is no problem.

The bit APIs below are the most generic; they are all macros
that will invoke the best possible function, depending on whether
the argument are constant or not.

@table @code
@item bit_on
Sets a bit flag.
@item bit_off
Clears a bit flag.
@item bit_toggle
Toggles a bit flag.
@item bit_test
Tests a bit flag.
@end table

@c ======================================================
@node Effects
@chapter Effects

Effect processing is a layer above the hardware which provides
controlled access to the lamps, display, flashers, and general
illumination.  It resolves contention when multiple tasks try to
access the same object at the same time through the use of
priorities.

The system manages three distinct types of effects: display, lamps, and
music.  They are fully independent of each other.  It is not possible
to request that all three types do something in sync with one another.
There are similarities between the way each type is handled, but all
three have fundamental differences.

Lamp effects manage both the regular lamps, plus the GI and flashers.

@menu
* Basic Effect Principles::    What all types of effects have in common
* Background Effects::         When an effect should always be running
* Display Effects::            Extra properties of display effects
* Lamp Effects::               Extra properties of lamps effects
* Sound and Music Effects::    Extra properties of sounds and music
* Lamplists::                  How to work with more than one lamp at a time
* DMD Transitions::            Wipes, fades, etc. on the display
@end menu

@node Basic Effect Principles
@section Basic Effect Principles

These principles apply to all kinds of effects.

At any time, there is at most 1 effect that is @emph{running}.  The
running effect is the one which has been @emph{started} with the
highest priority.  Priorities are simple integer values:
the higher the number, the more important the effect is.

It is possible for no effect to be running if none has been started.
In that case, the current priority is considered to be zero.  Actual
effects always have a priority that is non-zero.

The running effect is executed in a separate task context, except for
music, which is executed on a separate CPU.  The
currently running display effect always has the group ID
@code{GID_DEFF}; likewise @code{GID_LEFF} for the lamps.  Effects
that are started but not running do not have a task assigned to them,
and are simply marked as started in memory somehow.

These tasks can be preempted, if a higher priority effect is started.
In that case, the old task is killed, and a new task is started.

Effect functions must be declared in the machine configuration file.  Each
entry gives the entry point to the effect, along with its priority
and other optional properties.

The APIs and implementation for display/lamp effects are mostly the
same, but there are differences due to the following:

@itemize @bullet
@item The lamp matrix can be suballocated; the display can only be
allocated as a whole.
@item Some display effects are long-lived, while others are only
temporary.
@item Some display effects do not have high priority, but we should
retry to start it later if possible.
@end itemize

@node Background Effects
@section Background Effects

The display and music should always be doing something, even when
nothing really important is happening.  Thus, these effect modules
implement @dfn{background effects}, a way to determine what to do
in these circumstances.  Lamp effects do not support a background mode,
because in that case the lamp matrix is best left alone.

The strategy for handling background effects is as follows:  When
no effect has been explicitly started, an event is generated:
@code{display_update} or @code{music_refresh}.  Any module that can
provide a background effect should implement these handlers.

The function can decide which effect, if any, it wants to run by
calling either @code{deff_start_bg} or @code{music_request}.  It passes
the code for the deff or music plus a priority value.  After all of the
event handlers have been invoked, the one with the highest priority
will be started.

The common code provides many of the implementations to deal with the
usual cases.  For example, while a game is running, the default effect
is to show the game scores.  Default music codes can be defined for
different circumstances: normal game play, ball at plunger, during bonus.

Because handlers can use the values of other variables in the
determination (are we in game, for example?), the calculations need to
be redone periodically.  APIs exist to force a refresh: @code{deff_update}
and @code{music_update}.  The system will also invoke them occasionally,
on the order of a few times per second.

@node Display Effects
@section Display Effects

Display effects are defined in the @code{[deffs]} section of the machine
configuration file.  Both foreground and background deffs are defined here.
Each effect can have the following properties:

@itemize @code
@item D_QUEUED
Says that if the effect cannot be started now, to queue it and keep
retrying.
@item D_TIMEOUT
Only applies to D_QUEUED deffs.  Says that they should timeout
eventually if they cannot be started.
@item D_ABORTABLE
Says that pressing both flipper buttons will abort this effect.
@item D_PAUSE
Says that while this effect is running, ball kickouts are paused.
@item D_SCORE
Says that this is a score award effect; the value of the last switch
score is made available to the effect via the @code{score_get()} API.
@item D_RESTARTABLE
Says that if the effect is started when it is already running, that
it will be restarted (normally, the second call would do nothing).
This should generally be set on D_SCORE effects at least.
@end itemize

@table @code
@item deff_start
Starts a foreground display effect.
@item deff_stop
Stops a foreground display effect.
@item deff_exit
Exits from the currently running display effect.
@item deff_update
Request an update of the background display effect.
@end table

@node Lamp Effects
@section Lamp Effects

Lamp effects are defined in the @code{[leffs]} section of the machine
configuration file.  Each lamp effect defines a function that executes
when the effect is running, plus it says which of the lamps, flashers,
and G.I. strings it is able to modify.  Anything else continues to show
its current state, and if the function mistakenly tries to write to
those other objects, it won't have any effect.

The objects allocated to a lamp effect are guaranteed to be turned off
when the function starts.

A lamp effect can also be declared as @dfn{shared}.  A shared leff can
run in parallel with the current running leff, and with other shared
leffs.  Shared leffs have a lower priority than normal leffs; the
effect can be masked.  Also, shared leffs run to completion and are
never preempted.

Shared leffs are usually for indicating low-priority game state
that requires constant updating, such as when the jet bumpers are
maxed on @emph{Twilight Zone}.  Normal leffs are intended for light
shows.

Lamp effects cannot be aborted like display effects; also if a normal
leff cannot be started, it is forgotten.

@table @code
@item leff_start
Starts a lamp effect.
@item leff_stop
Stops a lamp effect.
@item leff_exit
Exits from the currently running lamp effect.
@end table

@node Sound and Music Effects
@section Sound and Music Effects

@table @code
@item music_update
Request an update of the background music.
@item sound_start
Start a sound effect.  This operates at a layer above @code{sound_send}.
@end table

@node Lamplists
@section Lamplists

Typically, groups of lamps are often used for a
similar purpose.  A lampset is a just of set of
lamps that are often controlled together.  Each
lampset has a unique ID, and is internally
represented by an array of lamp values, terminated
by a special lamp code named @code{LAMP_END}.

The lampset APIs provide convenience whenever
many lamps need to be updated at once.

@node DMD Transitions
@section DMD Transitions

A transition is an interim effect that runs between
the end of one display effect and the beginning of
another.  By default, a new effect will simply kill
the old one and overwrite it with a new image.

Transitions are scheduled -- a handler is installed
that runs the next time that a new image is shown.
Instead of showing the image right away, the transition
handler kicks in and displays some combination of
the present view and the new one.  When the transition
finishes, the display should consist entirely of the
new image.

Currently all transitions are contained in @file{common/dmdtrans.c}.

@c ======================================================
@node Ball Tracking
@chapter Ball Tracking

The ball tracking module keeps track of where all of the pinballs are in
the machine.  It is implemented in @file{common/device.c} and uses
container declarations in the machine description.

A @dfn{device} is defined to be something which can hold and release pinballs.
(Earlier versions of the software used the term @emph{container}.)
A device is comprised of one or more switches which count the number of balls
in the device, plus a release solenoid that can be pulsed to force one
ball to be removed.

Ball troughs, kickouts, poppers, saucers, and locks are all just different
shapes that a device can take.  Some containers only hold one ball, while
others can hold many.

@section Device Status

For each device, the ball tracker maintains the following state information:

@itemize @bullet
@item The maximum number of balls it can hold (constant)
@item The current number of balls it has
@item The desired number of balls
@item Whether or not it is in the process of trying to release a ball
@end itemize

The @dfn{desired count} is crucial to understanding the module's behavior.
Whenever it has more balls than desired, it will initiate one or more releases
to try to bring the count down to the desired number.  Otherwise, any balls
that enter the device are kept there; this is used to implement ball locks.

Software requests to kick a ball are @emph{always} done by manipulating the
desired count.  The device module has complete control over the actual
release solenoid.

The trough device is the only device which normally desires to keep any balls.
Playfield devices generally want zero balls unless a lock has been enabled.

Device switches msut be declared as @emph{edge} switches, which invoke the
event handler on both open and close transitions.  The tracker simply updates
the current count on either type of transition.

@section Global Status

The ball tracker also maintains a count of the number of balls in play,
which is the total number of balls installed, minus the number of balls
that are seen in devices, minus the number of balls declared "missing".
Missing balls are flagged when a game is started but the balls are not
all seen.

@section Events

The ball tracker also generates new per-device events.  The name of
the event includes the name of the device: for example,
@code{dev_trough_enter}.

The @dfn{enter} event is generated when the current count goes up by 1.
Game code should normally always register handlers for the enter events
rather than individual switches.  Note that a switch closure does not
always indicate enter: consider an eject that is trying to kick out
but the kicker is weak, so that the ball falls back in immediately.
Also, when a ball trough releases a ball, a whole series of switch
closures occur rapidly, but eventually it stabilizes.  The ball
tracker waits a little while after switch change before it begins
to take action.

The @dfn{kick_success} event is generated when a release is deemed successful.
It happens after a release cycle, when the count goes down by 1.  There
is also the @dfn{kick_failure} event for handling a failed kick, and the
@dfn{kick_attempt} event to signal that a kick is imminent; this usually
triggers a sound effect, but it can also delay the kick for some reason.

@section The Trough Device

The trough device is special; every game must have one.  The system
completely handles the device events generated for the ball trough.
The function @code{device_add_live} is called whenever a new ball
is added to play.

Likewise, @code{device_remove_live} is called whenever a ball drains.
It ultimately is the one that generates the @code{end_ball} event
when all balls have drained.

The trough also generates some events related to the total ball count.
@code{single_ball_play} is generated when the total number of balls
in play is reduced to 1,
as at the end of multiball.  Multiball modes use this to exit.
There is also @code{ball_count_change} invoked on every change of
the number of balls in play.


@c ======================================================
@node Test Mode
@chapter Test Mode

The FreeWPC test mode works similarly to the original WPC menu system.
However, there are extra options and a few important differences.
For testing core changes to FreeWPC, it is often more convenient to use
test mode than to play a game.

When compiling with the @code{MACHINE_TEST_ONLY} option, the game
will boot directly into test mode, and there is no provision to start a game.

@section Adjustments

All of the @emph{standard adjustments} are supported.  There are also a few
new adjustments.

@subsection Timed Game

This adjustment allows you to switch between normal game play and a timed
game.  Machines can implement different rules for timed play or not.
They can also disable it entirely.

@subsection Switch Stress Test

The switch stress test is used to test switch handling over a long
period of time.  When enabled, this adjustment causes the game to
pretend that switch closures are occurring randomly after the ball
has been plunged into play.  You can force end-of-ball by putting
the ball into the drain.  You can also park the ball somewhere and
the machine will continue to simulate closures indefinitely.

Closures are simulated randomly at a rate of about 10 per second.
This test has been used to uncover some hard to find bugs in the game
logic after extended play.

Naturally, this feature is disabled by default.

@section Audits

All of the @emph{standard audits} are supported.

Presently, audits are kept as 16-bit integers, so they max out at 65535.

@section Tests

The test menu contains roughly the same tests as in the actual WPC
games, with some differences.

@subsection Solenoid Test

The solenoid test lets you control the duration and duty cycle of
each coil pulse by using the flipper buttons.

@section Development

The development menu contains a series of additional tests that are
probably only relevant to developers and not to end users.

@subsection Font Test

Cycles through all of the available fonts.  Use the flipper buttons
to scroll through the alphabet.  The machine will try to display
as much as possible at once, depending on the font size.

@subsection Display Effect Test

Cycles through all display effects.  Press ENTER to activate a deff,
as if @code{deff_start} were called.  For long-running effects, press
ENTER again to stop it via @code{deff_stop}.

@subsection Lamp Effect Test

Cycles through all lamp effects.  Press ENTER to activate a leff,
as if @code{leff_start} were called.  Press ENTER again to stop it.

Remember that multiple lamp effects can be active simultaneously if
they are declared as shared and they do not overlap in the lamps that
they use.

@subsection Lamplist Test

Cycles through the lamplists.  The flipper buttons cycle through the
different ways that the lamplist can be controlled.  The default is
to turn on all of the lamps.  You can also strobe them, flash them, etc.

@subsection Ball Device Test

Cycles through each of the ball devices, telling you its current status
(how many balls it sees, kickouts pending, errors).  The flipper buttons
will scroll through a set of actions (empty, kick 1, etc.); press ENTER
to perform the action displayed.

This test also continuously shows the global device status, such as
how many total balls are detected and whether any balls are missing.

@subsection Random Test

Tests the random number generator.

@subsection Transition Test

Cycles through all of the dot-matrix or alphanumeric transition effects.

@subsection Frame Test

Cycles through all of the display frames.

@subsection Force Error Test

Entering this test forces a fatal error, which should restart the system.

@subsection Display Stress Test

Starts randomly starting and stopping display effects until exiting the test.

@subsection Symbol Test

Cycles through the symbol bitmap, a collection of arrows, boxes, etc.

@subsection Score Test

Advance through the various combinations of players per game and
player-up, to show how the score screen would look.

@subsection PIC Test

Displays vital data about the PIC.

@subsection Memory Editor

Lets you interactively scroll through the CPU's memory and alter values.

@c ======================================================
@node Common Pinball Library
@chapter Common Pinball Library

The files in the @file{common} directory provide a library of generic
pinball functions that can be reused from game to game.  Some of the more
important ones are described in detail in this chapter.

@section Coins and Pricing

FreeWPC implements a weak form of coin switch handling.  It is not
very robust and does not time the coins as it should.

If @code{FREE_ONLY} is defined, it will build a ROM that doesn't require
coins.

@section Extra Balls
@section High Scores
@section Enter Initials

@section Tournament Mode

FreeWPC implements a tournament mode module.  Note this is what newer
Stern games refer to as @emph{competition mode}.

Tournament mode can be enabled globally in the adjustments menu, or
it can be enabled by holding down the left flipper button briefly
before starting the game.  A message will indicate that tournament mode
has been enabled.  It affects all players in the game.

Software should check the @code{tournament_mode_enabled} boolean variable
to determine if tournament is in effect.

@section Ball Search

Machines don't need to do much to produce a working ball search function.
The common code knows how to pulse all of the regular solenoids.
It also knows which solenoids @emph{not} to fire.

Machines that need to handle a particular power driver in a non-standard
way should implement a @code{ball_search} event handler, and mark the
associated solenoid as @code{nosearch} to prevent the common code from
touching it.  The @code{ball_search} handler will be called to allow
the machine to decide what needs to be done.

For example, on Funhouse, the Rudy saucer eject needs to make sure that
the mouth is open before kicking.

@section Knocker Driver

@section Security PIC Module

The PIC module will initialize the PIC correctly and refresh it
periodically to keep it returning valid data.

@section Player Local Data

To support multiplayer games, FreeWPC maintains 5 separate copies of the
variables that are marked @code{__local__}.  One of these is the "live" copy and
is where the linker places the variables.  The other four are holding buffers that are
used when the player is not up.  When switching between players, the current local
variables are swapped out to that player's holding area, and the new player's
variables are then swapped in.

In single-player games, none of this happens and the variables stay in the live
area all the time.

@section Adjustments

@section Audits

Audits are 16-bit variables kept in the non-volatile area of memory.  They
are generally incremented via the @code{audit_increment} API, which adds 1.
They can also be incremented by an arbitrary value, via @code{audit_add}; or
they can be assigned via @code{audit_assign}.

@section Scoring

@c ======================================================
@node Fonts and Graphics
@chapter Fonts and Graphics

This chapter explains how FreeWPC fonts and graphics work.

FreeWPC uses simple bitmaps to represent fonts, icons, and full-screen
graphics.  A @dfn{bitmap} is an array of rectangular pixel data.
The data bits are prefixed by a short header which contains the width
and height information.  The image is stored one row at a time, starting
from the top.  Within a row, the bits are stored in little-endian format,
with the least significant bit representing the leftmost pixel.

A @dfn{font} is a set of bitmaps mapped to a contiguous sequence of
characters.  The font header identifies the ASCII code for the first
bitmap that is represented; this saves space by not needing to encode
the low-valued ASCII control characters.  The nominal height of the
characters is also defined, which allows for descenders.

A @dfn{frame} is a full-screen bitmap, 128x32.  Since these are fairly
common, special APIs are used to draw them that are more optimal, and
the width/height is implied and not actually stored in the bitmap.
A frame can have 4 colors per pixel (3 shades plus black) so
the frame is actually stored as two consecutive @dfn{bit planes}.

@section Compression

Each bit plane of a frame can optionally be compressed using run-length
encoding (RLE) or zero suppression to save space.  An uncompressed
frame requires 1KB, which limits the total number of frames in a ROM
significantly.  Every frame header includes
a flags field, which indicates which if any compression method was used.
The decoders are written in assembly language in @code{platform/wpc/dmd.s}.

@itemize @bullet

@item Run-Length Encoding

Useful for images that contain long sequences of the same byte value.
Each long run is replaced by a 3-byte code: the first byte is the code
0xA8, which signals an @dfn{escape sequence}, the second byte is the
number of bytes divided by 2 (so the length must be even), and the
third byte is the repeated value.  A special two-byte code also
indicate end of frame, so that the decoder does not need to count
the number of decoded bytes.

@item Sparse Encoding

The sparse format encodes images that contain mostly zeroes, or
which have large transparent sections that do not require writing
to the display.  The image is encoded as a series of
(length, data, move) triples, where the @var{move} value says how
many bytes forward to move the cursor.

@end itemize

@section Using TrueType Fonts

The script @command{fontgen2} converts TrueType font files (.ttf files)
into WPC font files (.fon).

@section Printing Text

FreeWPC contains a @code{printf}-like function for rendering text
strings, however, it is not quite the same.

The @code{sprintf()} function formats a string into a unique,
@emph{global} buffer named @code{sprintf_buffer}.  It is like the
actual C function of the same name, but the first argument is implied.

The format specifiers are also slightly different.  Here is a list of
the valid ones:

@table @code

@item %b

Print a binary-coded decimal value.  The format length gives the total
number of digits; for example, @code{%8b} would print a 4-byte BCD
string containing 8 digits.  Also, this format will insert commas
(or periods) between digits as necessary.

@item %c

Print a single 8-bit ASCII character.

@item %d

Print an 8-bit decimal integer (declared @code{U8}).

@item %E

When this is the first specifier in a string, it will cause
all output to be appended to the previous string in the print
buffer, rather than overwriting it completely.

@item %ld

Print a 16-bit decimal integer (declared @code{U16}).

@item %lx

Print a 16-bit hexadecimal integer (declared @code{U16}).

@item %p

Print a pointer.

@item %s

Print a string.

@item %w

Print a 32-bit hexadecimal integer (declared @code{U32}).

@item %x

Print an 8-bit hexadecimal integer (declared @code{U8}).

@end table

Like in C, you can insert a number in front of the format letter to
limit the output to a particular width.  If the length begins with
'0', then it will be padded with leading zeroes if necessary.

The formatter does not support signed numbers, and will print them as
if they were declared unsigned.

The formatter is not particularly efficient for printing large decimal
values, as the 6809 is not very good at long division.

@section Frame List

The list of all frames compiled in the ROM is defined in an
@dfn{image map}.  This is a machine-specific file that says which
images to copy into the final ROM image.

There can be multiple frame list files.  The common code
provides a frame list of standard images, like the FreeWPC logo,
which go into every build.

Each frame can be assigned a frame ID in the file.  The
image linker writes the file @file{build/imagemap.h} which
contains a list of all the frame IDs.  These are used by the
frame drawing APIs to refer to a particular frame.

@c ======================================================
@node Native Mode
@chapter Native Mode

Native mode lets you run the code directly on your host machine.
It is a form of emulation, like PinMAME, except the emulator is
"built-in" to the game ROM itself.

The main difference in native mode is that all I/O accesses
are emulated.  Calls to @code{readb} and @code{writeb} are
converted to call @code{linux_asic_read} or @code{linux_asic_write},
which does the emulation.

Also, because native mode runs under an existing operating system,
the lowest-level OS features in FreeWPC are bypassed.  For example,
the multitasking APIs are emulated using a system threads library.

Other features of native mode:

@itemize @bullet

@item You can use GDB to debug the program.

@item printf statements can be used in interrupt handlers, because
they don't really run in interrupt context.  They are run in a
regular user thread.

@item Permanent and NVRAM variables are supported; their values are
saved in files across program runs.  NVRAM variables are not
actually write-protected while the program is running, though.

@end itemize

Although FreeWPC aims to be portable to other platforms than just
WPC, the native mode support is WPC-specific for the moment.

@c ======================================================
@node Debugging
@chapter Debugging

You can use the @code{dbprintf()} function to print debug
messages.  What happens to these messages depends on how
you compile the code and what emulator you use.

For now, there is no debug support when you are running on
real hardware.

@section @command{wpcdebug} and @command{PinMAME}

PinMAME has been modified to support a new register, the
@dfn{debugger port}.  It acts like a serial port and can
be used to communicate between the running program and a
separate debug console.  The program @command{wpcdebug} is
the console.  Run this at the same time as PinMame and you
will see the debug messages printed out.  The two programs
use a socket to send data back and forth.

The console also accepts keyboard input and passes it back
to the running program.  Several keys will cause FreeWPC
to dump some of its internal data structures.  See
@file{common/db.c}.

If you cannot recompile PinMAME,
you can compile the ROM with the @code{CONFIG_PARALLEL_DEBUG}
option.  This will use the WPC parallel port for all debug
messages.  All versions of PinMAME support this, and
will write the output to a file in the @file{nvram} directory.
Under Windows, these files cannot be read while the program is
still running.

These virtual ports are unlike any real serial port, in that writes can
be done infinitely fast.  FreeWPC does not do any sort of timing on
the writes; it is an oversimplification but it works.

@section @command{gdb}

In native mode only, you can use @command{gdb} as you would on
any other program.  Because native mode uses @command{ncurses}, however,
it is best to run the debugger in a separate window from the program
itself.

Start FreeWPC as usual, then from another window, run @command{make attach}.
(See the Makefile to see what this does; you really don't need to be
in the source tree to do it.)  gdb starts, searches for the PID of the program,
and attaches to it.  The program will stop, and you can then control it from
the gdb prompt.

There are some special gdb macros provided in @file{gdbmacros}.
All of the usual breakpoints, stepping, and variable evaluation
commands work as you would expect.

@section @command{exec09}

exec09 is the 6809 emulator that is provided with GCC6809.
exec09 supports a subset of the WPC architecture and can be used
as a replacement for PinMAME.  It is mostly good for debugging
straight CPU code that does not access hardware.  It provides
a command-line monitor with breakpoints, single-step, and symbolic
debugging which is sometimes more useful than PinMAME or gdb.

exec09 can measure the length of time a function takes, including
interrupt handlers, which is good for determining performance.

@c ======================================================

@c ======================================================
@node The Machine Definition
@appendix The Machine Definition

@include md.texi

@c ======================================================
@node System Events
@appendix System Events

Here is a list of all of the standard events that the system generates.

@include events.texi

@c ======================================================
@node Build Tools
@appendix Build Tools

@section csum : ROM Checksum Tool

The checksum tool works on FreeWPC ROMs as well as the original
Williams factory ROMs.  It can verify and update the checksum
field located just above the interrupt vector table.

The checksum is a 16-bit value that resides at logical address
0xFFEE (18 bytes from the top of ROM).  This value should equal the
sum of all the 8-bit byte values in the ROM, modulo 65536.  The
checksum word is itself included when calculating and verifying it.

@command{csum} also uses the word at address 0xFFEC as a
@dfn{fixup word}, which can be set to any value to help make the
checksum match.

@section srec2bin : S-Record Converter

The gcc6809 linker produces S-record files by default.  This
tool converts S-records to raw binary format.

Each bank of the ROM is linked individually; each produces an S-record
file.  These files contain nearly everything to generate a binary file,
except for the size and the value to place at holes.  We use 0xFF
for all holes as this is more friendly to EPROMs.

@section sched : Static Scheduler

The scheduler reads in a list of schedule files, which by
convention end with the extension @file{.sched}.  Each entry gives
a function and a frequency at which it should be called.
It generates a C source file that contains a top-level function
which then calls all of those functions at the right rate.  It does
this by keeping a counter of the number of times that the top
function was called.

The scheduler supports @dfn{loop unrolling}, where the top
function is actually decomposed into a small number of functions.
This reduces the number of if-statements needed overall; it does
require an extra indirection via function pointer.  This can
cause code duplication for the sake of speed.  The unroller tries
to balance all of the functions to be scheduled using performance
data in the schedule file.

@section fontgen2 : TrueType Font Generator

This is a short Perl script which can transform a TrueType
font file (@file{.ttf}) into FreeWPC source code.  It requires
the @command{convert} program from the ImageMagick tool suite.

@c ======================================================

@include dmd-theory.texi

@node Historical Notes
@appendix Historical Notes

FreeWPC was started in 2005 and was written entirely in assembly language,
before the availability of the gcc6809 C compiler.  An initial attempt
to ease programming involved the use of some complicated macros, written
in the @command{m4} programming language.  Work was halted during the
development of gcc6809, then the system was gradually rewritten in C.
The early source code repository actually contained the compiler changes
as well.

The first time that a FreeWPC ROM was placed into a game was in
May, 2008.  It did not run OK due to some problems with the watchdog
circuit and with the PIC initialization.  Those problems were
resolved within only a few hours.


