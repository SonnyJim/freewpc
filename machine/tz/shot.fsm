#
# FSM for Twilight Zone shots
# (C) Copyright 2006, 2007 by Brian Dominy.  All Rights Reserved.
#

# Syntax:
#
# An FSM file defines one or more autonomous "state machines".  
# Each element of an FSM is a transition rule of the form
#
#    <initial-state(s)> : <event> => <new-state>
#
# which says how to transition states based on events.  The event names 
# given here correspond to those generated by "gencallset".
#
# For each transition, an optional block of code may be written that 
# is executed when the transition occurs.  The code block may use the 
# "throw <event>" syntax to generate new events.
#
# The script tools/fsmgen translates this description into C code.
#

#################################################################
# Recognize loop shots.
#################################################################

loopshots {
	# Reinitialize at the start of each ball
	# TODO : fsmgen provides no way to merge these two rules
	* : start_ball => INIT
	* : end_ball => INIT

	# When idle, the first magnet tripped changes the state.
	# Either right-side magnet is treated the same.
	INIT : sw_left_magnet => left_loop_started 
	INIT : sw_upper_right_magnet => right_loop_started
	INIT : sw_lower_right_magnet => right_loop_started

	# Left loop completion rules
	left_loop_started : sw_upper_right_magnet => left_loop_made
		{
			throw shot_left_loop;
		}
	left_loop_started : sw_lower_right_magnet => left_loop_made
		{
			throw shot_left_loop;
		}

	# Right loop completion rule
	right_loop_started : sw_left_magnet => right_loop_made
		{
			throw shot_right_loop;
		}

	# Timeouts if a loop is started but never completed
	left_loop_started, right_loop_started : TIME_3S => INIT

	# Delay period between a made loop and allowing another
	# loop to start (?)
	left_loop_made, right_loop_made : TIME_1S => INIT

	# TODO : add 'abort' rules, when the entry switch occurs
	# again

	# TODO : add 'multiball' rule which disables the FSM
	# completely in multiball play.
}

#################################################################
# Recognize skill shots.
#################################################################

# Recognize combo shots.
# Combo 1 = Left Ramp/Right Ramp
# Combo 2 = Left Ramp/Right Ramp/Piano
# Combo 3 = Left Loop/Hitchhiker
combos {
	* : start_ball => INIT
	INIT : sw_left_ramp_exit => 1of3
	1of3 : sw_right_ramp => 2of3
	2of3 : sw_piano => 3of3
}


skillshot {
	* : init => INIT
	INIT : enable_skill_shot => ready
	ready : disable_skill_shot => INIT

	ready : sw_skill_bottom => red
	ready, red : sw_skill_center => orange
	ready, red, orange : sw_skill_top => yellow
	ready, red, orange, yellow : sw_slot => missed
	{
		throw skill_shot_miss;
	}
	yellow : any_skill_switch, TIME_1S => INIT
	{
		throw skill_shot_yellow;
	}
	orange : sw_skill_bottom, TIME_1S => INIT
	{
		throw skill_shot_orange;
	}
	red : TIME_1S => INIT
	{
		throw skill_shot_red;
	}
}


# A template declaration (not supported yet -- this is theoretical :-).
# This provides the common framework for FSM, but which is
# parameterized.  Substitutions are entirely textual and
# similar to a #define.
#
#template gatedramp<gate_switch, made_switch, timeout, enter_event, \
#   made_event, abort_event> {
#	* : init => INIT
#	INIT : gate_switch => entered
#	{
#		throw enter_event;
#	}
#	INIT, entered : made_switch => INIT
#	{
#		throw made_event;
#	}
#	entered : timeout, gate_switch => INIT
#	{
#		throw abort_event;
#	}
#}
#
# An example of a template instantiation:
#
# left_ramp_shot : gatedramp<sw_left_ramp_enter, sw_left_ramp_made, \
#   timeout, left_ramp_enter, left_ramp_made, left_ramp_abort> {
# }
#
# Note that this is a sufficient definition.  We could also
# include additional rules here that would extend or override the
# rules in the template.
#

# Another template example:
#
# template always_precedes<s1, s2, timeout> {
# 	* : init => INIT
# 	INIT, started : s1 => started
# 	started : s2 => INIT
# 	started : timeout => INIT
# 	INIT : s2 => INIT
# 	{
# 		throw s1;
# 	}
# }

