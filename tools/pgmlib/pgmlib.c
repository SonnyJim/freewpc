/*
 * Copyright 2006, 2007 by Brian Dominy <brian@oddchange.com>
 *
 * This file is part of FreeWPC.
 *
 * FreeWPC is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 * 
 * FreeWPC is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with FreeWPC; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 */

/**
 * pgmlib is a library of functions for manipulating graphics images that
 * are supported on the FreeWPC platform.
 *
 * To use, you write a C source file with a function named machgen() and
 * link it with pgmlib.  (pgmlib provides the main function -- you should
 * not write one yourself.)  When compiled, this produces a program that
 * will initialize the PGM library, parse recognized command-line options,
 * then invoke your machgen() function, which should do whatever it is you
 * want to do.
 *
 * The library provides the following data structures:
 *
 * PGM is the preferred internal image format.  If you're generating a 
 * new image from scratch, create a PGM using pgm_alloc().  You should 
 * also set the number of planes using pgm_set_mono() or pgm_set_four_color().
 *
 * XBM is a simpler format, but it only supports 1 bit plane.  Use
 * pgm_write_xbm() to downconvert a PGM into XBM format.
 *
 * XBMSET is a FreeWPC construction, where multiple XBM images are 
 * output in the same file.  This is the preferred output format.
 * Use pgm_write_xbmset() to downconvert a PGM to an xbmset.
 * 
 * XBMPROG is also a FreeWPC construction.  It is a compressed 
 * XBM format, similar to XBM (1-bit) but with certain byte values
 * assigned special meaning.  It requires a decoder in order to display
 * these.  FreeWPC dmd.c can show these using the dmd_draw_xbmprog()
 * routine.
 **/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "pgmlib.h"
#include "xbmprog.h"

unsigned int opt_debug = 0;

/** Zero when the -q option is given to turn on verbose messages. */
unsigned int opt_verbose = 1;

unsigned int opt_compress = 1;

/** The name of a makefile fragment.  This file contains the names of
 * all of the XBM files that were generated by the program, along with
 * rules on how to build them.
 */
const char *opt_makefile_fragment_name = "build/Makefile.xbms";


#define dprintf(format, rest...)	\
	if (opt_debug) fprintf (stderr, format, ## rest)


/** Allocate some memory */
inline void *xmalloc (size_t size)
{
	return malloc (size);
}


/** Allocate a new xbmprog */
XBMPROG *
xbmprog_alloc (void)
{
	XBMPROG *xbmprog = xmalloc (sizeof (XBMPROG));
	return (xbmprog);
}


/** Free an xbmprog */
void
xbmprog_free (XBMPROG *prog)
{
	XBMPROG * elem = prog;
	XBMPROG * tmp;
	do {
		tmp = elem->next;
		free (elem);
		elem = tmp;
	} while (elem != prog);
}


/** Returns zero if two XBM program elements are the same */
int
xbmprog_equal_p (XBMPROG *prog1, XBMPROG *prog2)
{
	if (prog1->op != prog2->op)
		return 1;

	switch (prog1->op)
	{
		default:
			return 0;
		case XBMOP_LITERAL:
			return prog1->args.literal.count == prog2->args.literal.count
				&& !memcmp (prog1->args.literal.bytes,
						prog2->args.literal.bytes,
						prog1->args.literal.count);

		case XBMOP_REPEAT_BYTE:
			return prog1->args.repeat.count == prog2->args.repeat.count
				&& prog1->args.repeat.data && prog2->args.repeat.data;

		case XBMOP_REPEAT_WORD:
		case XBMOP_SKIP:
			return prog1->args.skip.count == prog2->args.skip.count;
	}

	return 0;
}


/** Writes an XBMPROG to a file. */
void
xbmprog_write (FILE *fp, const char *name, int plane, XBMPROG *xbmprog)
{
	int i;
	unsigned int size = 0;
	XBMPROG *head = xbmprog;

	if (name)
	{
		/* xbmprog.h is not normally included and thus must be added */
		fprintf (fp, "#include <freewpc.h>\n");
		fprintf (fp, "#include <xbmprog.h>\n");
	
		/* Start the declaration */
		fprintf (fp, "__xbmprog__ unsigned char %s%d_prg[] = { 0x%02X,\n",
			name, plane, head->stats.flags);
	}

	/* Write each element of the xbmprog */
	do {
		switch (xbmprog->op)
		{
			case XBMOP_LITERAL:
				/* Write 1 or more literal bytes that couldn't be compressed */
				for (i=0; i < xbmprog->args.literal.count; i++)
				{
					unsigned char c = xbmprog->args.literal.bytes[i];
					if ((c == XBMPROG_RLE_SKIP) || (c == XBMPROG_RLE_REPEAT))
					{
						/* We can't output a literal for any byte that matches
						a prefix flag.  This must be encoded as sequences of 1
						byte. */
						fprintf (fp, "XBMPROG_RLE_REPEAT, 0x%02X, 1, ", c);
					}
					else
					{
						fprintf (fp, "0x%02X, ", c);
					}
				}
				size += xbmprog->args.literal.count + 1;
				break;
			case XBMOP_SKIP:
				/* Write a skip sequence */
				fprintf (fp, "XBMPROG_RLE_SKIP, %d, ", xbmprog->args.skip.count);
				size++;
				break;
			case XBMOP_REPEAT_BYTE:
				/* Write a repeat sequence */
				fprintf (fp, "XBMPROG_RLE_REPEAT, 0x%02X, %d, ", 
					xbmprog->args.repeat.data, xbmprog->args.repeat.count);
				size += 2;
				break;
			default:
				fprintf (fp, "!!! bad opcode %02X\n", xbmprog->op);
				goto done;
		}
		xbmprog = xbmprog->next;
	} while (xbmprog != head);

done:
	/* Finish the declaration */
	if (name)
	{
		fprintf (fp, "\n// size = %d\n", head->stats.size);
		fprintf (fp, "};\n");
	}
}


static int
xbm_read_byte (XBM *xbm, int offset)
{
	int y = offset / ((xbm->width + 7) / 8);
	int x = offset % ((xbm->width + 7) / 8);
	return xbm->bytes[y][x];
}


/** Makes an XBM Program from an XBM image.  This effectively
 * compresses the XBM.  The XBMPROG is not the final encoded form
 * of the program, but rather an internal format that can be
 * further manipulated before writing it.
 */
XBMPROG *
xbm_make_prog (XBM *xbm)
{
	XBMPROG *head = NULL, *tail = NULL;
	unsigned int off = 0;
	unsigned int n_bytes;
	unsigned int byte;
	unsigned int count;
	XBMPROG *elem;
	unsigned int size = 0;

	n_bytes = ((xbm->width + 7) / 8) * xbm->height;
	dprintf ("Image has %d bytes total.\n", n_bytes);
	while (off < n_bytes)
	{
		elem = NULL;

		/* At the current offset, which is the best way of compressing
		the next sequence of data? */

		/* Scan for a repeating sequence. */
		byte = xbm_read_byte (xbm, off);
		count = 1;
		while ((xbm_read_byte (xbm, off+count) == byte)
			&& (off+count < n_bytes) && (count < 255))
			count++;

		if (count <= 2)
		{
			/* If the run length is 1 or 2, then there's no value
			in compressing this, so output a literal.
			If the last output was a literal, then try to append
			to that, otherwise allocate a new literal. */
			if (tail 
				&& tail->op == XBMOP_LITERAL
				&& tail->args.literal.count < 16)
			{
				tail->args.literal.bytes [ tail->args.literal.count++ ] = byte;
			}
			else
			{
				elem = xbmprog_alloc ();
				elem->op = XBMOP_LITERAL;
				elem->args.literal.count = 0;
				elem->args.literal.bytes [ elem->args.literal.count++ ] = byte;
			}
			off++;
			size++;
		}
		else if (byte == 0)
		{
			/* Repeated zeroes are especially optimal.
			Output a skip. */
			elem = xbmprog_alloc ();
			elem->op = XBMOP_SKIP;
			elem->args.skip.count = count;
			off += count;
			size += 2;
		}
		else
		{
			/* Output a repeat. */
			elem = xbmprog_alloc ();
			elem->op = XBMOP_REPEAT_BYTE;
			elem->args.repeat.count = count;
			elem->args.repeat.data = byte;
			off += count;
			size += 3;
		}

		if (elem)
		{
			/* If we created a new element, add it to the chain. */
			if (head == NULL)
			{
				elem->prev = elem->next = elem;
				head = tail = elem;
			}
			else
			{
				tail->next = head->prev = elem;
				elem->prev = tail;
				elem->next = head;
				tail = elem;
			}
		}
	}

	head->stats.flags = XBMPROG_METHOD_RLE;
	head->stats.size = size;
	return (head);
}


XBMSET *
pgm_append_xbmset (XBMSET *xbmset, PGM *pgm)
{
	unsigned int plane, x, y;
	XBM *xbm;

	if (xbmset == NULL)
	{
		xbmset = xmalloc (sizeof (XBMSET));
		xbmset->frame_count = 0;
		xbmset->c_name = "image";

		switch (pgm->maxval)
		{
			case 1:
				xbmset->n_planes = 1;
				break;
			case 3:
				xbmset->n_planes = 2;
				break;
			default:
				fprintf (stderr, "Invalid maxval %d for XBM conversion", pgm->maxval);
				exit (1);
		}
	}

	for (plane = 0; plane < xbmset->n_planes; plane++)
	{
		xbm = xbmset->planes[plane][xbmset->frame_count] = xmalloc (sizeof (XBM));
		xbm->width = pgm->width;
		xbm->height = pgm->height;
		memset (xbm->bytes, 0, sizeof (xbm->bytes));

		for (x = 0; x < pgm->width; x++)
		{
			for (y = 0; y < pgm->height; y++)
			{
				xbm->bytes[y][x / 8] |= 
					((pgm->bits[y][x] & (1 << plane)) << (x % 8)) >> plane;
			}
		}
	}

	xbmset->frame_count++;
	return (xbmset);
}


int
xbm_unique_byte_count (XBM * xbm)
{
	unsigned int x, y;
	unsigned int bytemap[256] = { 0, };
	unsigned int unique_count = 0;

	for (y = 0; y < xbm->height; y++)
		for (x = 0; x < (xbm->width + 7) / 8; x++)
		{
			if (bytemap[xbm->bytes[y][x]] == 0)
				unique_count++;
			bytemap[xbm->bytes[y][x]]++;
		}

	return unique_count;
}


int
xbm_zero_count (XBM *xbm)
{
	unsigned int x, y;
	unsigned int zero_count = 0;

	for (y = 0; y < xbm->height; y++)
		for (x = 0; x < (xbm->width + 7) / 8; x++)
		{
			if (xbm->bytes[y][x] == 0)
				zero_count++;
		}

	return zero_count;
}


void
xbm_write_stats (FILE *fp, XBM *xbm)
{
	fprintf (fp, "/* Statistics:\n");
	fprintf (fp, " * unique_byte_count = %d\n", xbm_unique_byte_count (xbm));
	fprintf (fp, " * zero_byte_count = %d\n", xbm_zero_count (xbm));
	fprintf (fp, " */\n");
}


/** Write an animation: a sequence of frames contained within an
xbmset */
void
xbmset_write_animation (FILE *fp, XBMSET *xbmset)
{
	int plane, frame;

	fprintf (fp, "#include <xbmprog.h>\n");

	/* TODO : need to work on this */
	fprintf (fp, "static unsigned char __end = XBMPROG_METHOD_END;\n");
	for (plane = xbmset->n_planes-1; plane >=0; plane--)
		for (frame = xbmset->frame_count-1; frame >= 0; frame--)
		{
			XBM *xbm = xbmset->planes[plane][frame];
			XBMPROG *xbmprog = xbm_make_prog (xbm);
			xbmprog_write (fp, xbmset->c_name, plane, xbmprog);
			xbmprog_free (xbmprog);
		}
}


/** Writes an XBMSET to a file. */
void
xbmset_write (FILE *fp, XBMSET *xbmset, int plane, int write_flags)
{
	unsigned int x, y;
	XBM *xbm;
	
	unsigned int bytes = 0;

	if (plane == XBMSET_ALL_PLANES)
	{
		/* TODO - the order in which planes are output should be
		different depending on the version of GCC being used.
		FreeWPC needs the planes in a particular order. */
		for (plane = xbmset->n_planes-1; plane >=0; plane--)
			xbmset_write (fp, xbmset, plane, write_flags);
		return;
	}

	xbm = xbmset->planes[plane][0];

	fprintf (fp, "#define %s%d_width %d\n", xbmset->c_name, plane, xbm->width);
	fprintf (fp, "#define %s%d_height %d\n", xbmset->c_name, plane, xbm->height);
	fprintf (fp, "static unsigned char %s%d_bits[] = {\n", xbmset->c_name, plane);

	if (write_flags & XBM_WRITE_HEADER)
		fprintf (fp, "0x%02x, 0x%02x,\n", xbm->width, xbm->height);

	for (y = 0; y < xbm->height; y++)
		for (x = 0; x < (xbm->width + 7) / 8; x++, bytes++)
		{
			fprintf (fp, "0x%02x, ", xbm->bytes[y][x]);
			if ((bytes % 8) == 7)
				fprintf (fp, "\n");
		}

	fprintf (fp, "};\n");

	if (opt_compress)
	{
		xbm_write_stats (fp, xbm);
		XBMPROG *xbmprog = xbm_make_prog (xbm);
		fprintf (fp, "/* -- compressed representation\n");
		xbmprog_write (fp, xbmset->c_name, plane, xbmprog);
		fprintf (fp, "*/\n");
		xbmprog_free (xbmprog);
	}
}


void
xbmset_free (XBMSET *xbmset)
{
	free (xbmset);
}


XBM *
xbmset_plane (XBMSET *xbmset, int plane)
{
	return xbmset->planes[plane][0];
}


/** Create a new PGM with default properties. */
PGM *
pgm_alloc (void)
{
	PGM *pgm = xmalloc (sizeof (PGM));
	pgm->width = MAX_WIDTH;
	pgm->height = MAX_HEIGHT;
	pgm->maxval = MAX_MAXVAL;
	memset (pgm->bits, 0, sizeof (pgm->bits));
	return (pgm);
}


/** Delete a PGM. */
void
pgm_free (PGM *pgm)
{
	free (pgm);
}


/** Change the width and height of a PGM. */
void
pgm_resize (PGM *pgm,
	unsigned int width, unsigned int height)
{
	pgm->width = width;
	pgm->height = height;
}


void
pgm_set_maxval (PGM *pgm,
	unsigned int depth)
{
	pgm->maxval = depth;
}


PGM *
pgm_read (const char *filename)
{
	PGM *pgm;
	FILE *fp;
	char line[80];
	unsigned int x, y;

	pgm = pgm_alloc ();
	fp = fopen (filename, "r");
	if (!fp)
	{
		pgm_free (pgm);
		return NULL;
	}

	fgets (line, 79, fp); /* magic */
	fgets (line, 79, fp); /* comment */

	fgets (line, 79, fp);
	sscanf (line, "%d %d", &pgm->width, &pgm->height);

	fgets (line, 79, fp);
	sscanf (line, "%d", &pgm->maxval);

	for (y=0; y < pgm->height; y++)
		for (x=0; x < pgm->width; x++)
		{
			fgets (line, 79, fp);
			sscanf (line, "%d\n", &pgm->bits[y][x]);
		}

	fclose (fp);
	return (pgm);
}


void
pgm_write (PGM *pgm, const char *filename)
{
	unsigned int x, y;

	FILE *fp = fopen (filename, "wb");
	fprintf (fp, "P2\n");
	fprintf (fp, "#\n");
	fprintf (fp, "%d %d\n", pgm->width, pgm->height);
	fprintf (fp, "%d\n", pgm->maxval);
	for (y = 0; y < pgm->height; y++)
		for (x = 0; x < pgm->width; x++)
			fprintf (fp, "%d\n", pgm->bits[y][x]);
	fclose (fp);
}


void
pgm_draw_pixel (PGM *pgm, 
	unsigned int x, unsigned int y, unsigned int val)
{
	pgm->bits[y][x] = val;
}


unsigned int
pgm_read_pixel (PGM *pgm, 
	unsigned int x, unsigned int y)
{
	return pgm->bits[y][x];
}


void
pgm_draw_hline (PGM *pgm, 
	unsigned int x1, unsigned int x2, unsigned int y, unsigned int val)
{
	unsigned int x;
	for (x = x1; x <= x2; x++)
		pgm_draw_pixel (pgm, x, y, val);
}


void
pgm_draw_vline (PGM *pgm, 
	unsigned int x, unsigned int y1, unsigned int y2, unsigned int val)
{
	unsigned int y;
	for (y = y1; y <= y2; y++)
		pgm_draw_pixel (pgm, x, y, val);
}


void
pgm_draw_box (PGM *pgm,
	unsigned int x1, unsigned int y1, unsigned int x2, unsigned int y2,
	unsigned int val)
{
	pgm_draw_hline (pgm, x1, x2, y1, val);
	pgm_draw_hline (pgm, x1, x2, y2, val);
	pgm_draw_vline (pgm, x1, y1, y2, val);
	pgm_draw_vline (pgm, x2, y1, y2, val);
}


void
pgm_draw_border (PGM *pgm,
	unsigned int width, unsigned int val)
{
	unsigned int off;
	for (off = 0; off < width; off++)
		pgm_draw_box (pgm, off, off, pgm->width - off - 1, pgm->height - off - 1, val);
}


void
pgm_fill_box (PGM *pgm,
	unsigned int x1, unsigned int y1, unsigned int x2, unsigned int y2,
	unsigned int val)
{
	unsigned int x, y;
	for (x = x1; x <= x2; x++)
		for (y = y1; y <= y2; y++)
			pgm_draw_pixel (pgm, x, y, val);
}


void
pgm_fill (PGM *pgm, unsigned int val)
{
	pgm_fill_box (pgm, 0, 0, pgm->width - 1, pgm->height - 1, val);
}


void
pgm_translate (PGM *dst, PGM *src,
	int xshift, int yshift)
{
	unsigned int x, y;
	for (x = 0; x < src->width; x++)
		for (y = 0; y < src->height; y++)
		{
			unsigned int pixel = pgm_read_pixel (src, x, y);
			
			if ((x+xshift >= 0) && (x+xshift < dst->width)
				&& (y+yshift >= 0) && (y+yshift < dst->height))
			{
				pgm_draw_pixel (dst, x+xshift, y+yshift, pixel);
			}
		}
}


void
pgm_paste (PGM *dst, PGM *src, unsigned int xpos, unsigned int ypos)
{
	unsigned int x, y;
	for (x = 0; x < src->width; x++)
		for (y = 0; y < src->height; y++)
			if ((xpos+x >= 0)
				&& (xpos+x < dst->width)
				&& (ypos+y >= 0)
				&& (ypos+y < dst->height))
				pgm_draw_pixel (dst, xpos+x, ypos+y, pgm_read_pixel (src, x, y));
}


void
pgm_scale (PGM *pgm,
	double factor)
{
}


void
pgm_xor (PGM *dst, PGM *src1, PGM *src2)
{
	unsigned int x, y;
	/* verify dst, src1 and src2 are the same size */
	for (x = 0; x < src1->width; x++)
		for (y = 0; y < src1->height; y++)
			pgm_draw_pixel (dst, x, y, 
				pgm_read_pixel (src1, x, y) ^ pgm_read_pixel (src2, x, y));
}


void
pgm_change_maxval (PGM *pgm, unsigned int new_maxval)
{
	unsigned int x, y;
	double factor;

	if (new_maxval == pgm->maxval)
		return;

	factor = pgm->maxval / new_maxval;
	for (y = 0; y < pgm->height; y++)
		for (x = 0; x < pgm->width; x++)
			pgm->bits[y][x] = ((unsigned int)(
				((double)pgm->bits[y][x] / factor) + 0.5));
	pgm->maxval = new_maxval;
}


void
pgm_pixel_add_saturated (PGM *pgm, unsigned int x, unsigned int y, int delta)
{
	int val = pgm->bits[y][x];
	val += delta;
	if (val < 0)
		val = 0;
	if (val > pgm->maxval)
		val = pgm->maxval;
	pgm->bits[y][x] = val;
}


void
pgm_dither (PGM *pgm, unsigned int new_maxval)
{
	unsigned int x, y;
	int factor;

	/* Dithering not appropriate here -- just bump the values */
	if (new_maxval >= pgm->maxval)
	{
		pgm_change_maxval (pgm, new_maxval);
		return;
	}

	factor = (pgm->maxval + 1) / (new_maxval+1);

	/* Apply the Floyd-Steinberg dithering algorithm. */
	for (y = 0; y < pgm->height; y++)
		for (x = 0; x < pgm->width; x++)
		{
			/* Calculate the new value for this pixel, after applying
			the scaling factor. */
			/* e.g. from 256 to 4 colors:
			0 -> 0
			64 -> 1
			128 -> 2
			192 -> 3
			(256) -> (4)
			*/
			unsigned int newval = (pgm->bits[y][x] / factor) * factor;

			/* Calculate the (signed) difference from the existing value */
			int diff = pgm->bits[y][x] - newval;

			/* Distribute the difference to adjacent cells.
			Take care not to underflow/overflow the values. */
			pgm_pixel_add_saturated (pgm, x-1, y+1, (3 * diff) >> 4);
			pgm_pixel_add_saturated (pgm, x, y+1, (5 * diff) >> 4);
			pgm_pixel_add_saturated (pgm, x+1, y+1, (1 * diff) >> 4);
			pgm_pixel_add_saturated (pgm, x+1, y, (7 * diff) >> 4);
		}

	for (y = 0; y < pgm->height; y++)
		for (x = 0; x < pgm->width; x++)
			pgm->bits[y][x] /= factor;
	pgm->maxval = new_maxval;
}


void
pgm_invert (PGM *pgm)
{
	unsigned int x, y;
	for (y = 0; y < pgm->height; y++)
		for (x = 0; x < pgm->width; x++)
			pgm->bits[y][x] = pgm->maxval - pgm->bits[y][x];
}


void
pgm_output_file (const char *filename)
{
#ifndef NO_MAIN
	FILE *fp;
	static int first_output = 0;
	char objname[64], *p;

	fp = fopen (opt_makefile_fragment_name, first_output ? "a" : "w");
	first_output = 1;

	strcpy (objname, filename);
	p = strchr (objname, '.');
	if (p)
		sprintf (p+1, "o");
	else
		strcat (objname, ".o");

	fprintf (fp, "%s : %s\n", objname, filename);
	fprintf (fp, "XBMGEN_OBJS += %s\n", objname);
	fclose (fp);
#endif
}


void
pgm_finish_output_file (void)
{
	FILE *fp = fopen (opt_makefile_fragment_name, "a");
	fprintf (fp, "xbmgen_objs : $(XBMGEN_OBJS)\n");
	fclose (fp);
}


void
pgm_write_xbmset (PGM *pgm, const char *filename, const char *name)
{
	XBMSET *xbmset;
	FILE *fp;

	xbmset = pgm_make_xbmset (pgm);
	xbmset_name (xbmset, name);
	fp = fopen (filename, "wb");
	pgm_output_file (filename);
	xbmset_write (fp, xbmset, XBMSET_ALL_PLANES, 0);
	fclose (fp);
	xbmset_free (xbmset);
}


void
pgm_write_xbm (PGM *pgm, const char *filename, const char *name, int plane)
{
	XBMSET *xbmset;
	FILE *fp;

	xbmset = pgm_make_xbmset (pgm);
	xbmset_name (xbmset, name);
	fp = fopen (filename, "wb");
	pgm_output_file (filename);
	xbmset_write (fp, xbmset, plane, 0);
	fclose (fp);
	xbmset_free (xbmset);
}


#ifndef NO_MAIN
#error "standalone binary for pgmlib no longer supported"
#endif /* NO_MAIN */
