\input texinfo
@c %**start of header
@setfilename freewpc.info
@settitle The FreeWPC Manual
@setchapternewpage odd
@c %**end of header

@set VERSION 0.90
@set COPYRIGHT 2006-2009

@titlepage
@title The FreeWPC Manual
@author Brian Dominy

@sp 10
@center @titlefont{}

@page
@vskip 0pt plus 1filll
Copyright @copyright{} @value{COPYRIGHT} by Brian Dominy.
@end titlepage

@contents

@ifnottex
@node Top
@top Introduction

This is the manual for @dfn{FreeWPC}, a free platform for developing replacement
game ROMs for Bally/Williams pinball machines based on the WPC
(Williams Pinball Controller) chip.  FreeWPC provides the foundation for building
new ROMs with custom game rules.  This document describes version
@value{VERSION} of the software.

FreeWPC is developed by Brian Dominy @email{brian@@oddchange.com} and is licensed
under the GNU General Public License version 2 or later.  The latest version of
the software can be obtained at @url{http://www.oddchange.com/freewpc}.
Developers should be familiar
with basic embedded systems programming concepts and the C programming
language.  Familiarity with 6809 assembler is highly recommended.
Also, knowledge of WPC pinball machines is very helpful.

@end ifnottex

@menu
* Overview::
* Installation::
* Compiling::
* The WPC Hardware::
* Software Environment::
* Hardware APIs::
* Effects::
* Ball Tracking::
* Test Mode::
* Common Pinball Library::
* Fonts and Graphics::
* Native Mode::
* Debugging::
* The Machine Definition::
* Event Handling::
* Build Tools::
* Dot-Matrix Performance::
* Historical Notes::
@end menu

@ignore
* Frame Rate::
* Simulating Color::
* 6809 Instruction Set::
* The Fastest Copy in Town::
* Bit Alignment::
* Compression Techniques::
* Binary Packages::
* Source Code Packages::
* Directory Layout::
* Configuration::
* Making the ROM::

@menu
* Multitasking::
* Real-Time Processing::
* Memory Allocation::
* Event Handling::
* Template Drivers::
* Fault Detection::
@end menu

* Switches::
* Lamps::
* Power Drivers::
* Zerocross Detector::
* Dot-Matrix Display (DMD)::
* Sound Board::
* Triacs and General Illumination::
* Real-Time Clock::
* High Precision Timer::
* Miscellaneous::
* Debug Port::
* Paging and Locking::
* Bit Shifting::

* Basic Effect Principles::
* Background Effects::
* Display Effects::
* Lamp Effects::
* Lamplists::
* DMD Transitions::

* Device Status::
* Global Status::
* Events::
* The Trough Device::

* Adjustments::
* Audits::
* Tests::
* Development::

* Coins and Pricing::
* Ball Devices::
* Extra Balls::
* High Scores::
* Enter Initials::
* Tournament Mode::
* Ball Search::
* Knocker Driver::
* PIC Driver::
* Player Local Data::
* Adjustments::
* Audits::
* Scoring::

* Compression::
* Using TrueType Fonts::
* Frame List::

* @command{wpcdebug} and @command{PinMAME}::
* @command{gdb}::
* @command{exec09}::
* csum : ROM Checksum Tool::
* srec2bin : S-Record Converter::
* sched : Static Scheduler::
* fontgen2 : TrueType Font Generator::

* Overview::
* CPU Board::
* Power Driver Board::
* Sound Board::
* Fliptronic Board::
* Auxiliary Driver Board::
* Dot Matrix Controller Board::
* Memory Map::

* Syntax::
* Fixed Objects::
* Variable Objects::
* Directives::
* Global Configuration::
* Section Summary::
* How genmachine works::
@end ignore

@node Overview
@chapter Overview

FreeWPC is a toolkit for building new software for Williams WPC pinball machines.
WPC is the hardware platform that was used in all games from 1990-1999, starting with
@samp{Funhouse} and ending with @samp{Cactus Canyon}.

This document provides an overview of the FreeWPC architecture for
developers who wish to understand how the system works.
The details provided here reflect the status of the latest development
branch.  FreeWPC is constantly evolving and the information here is
subject to change.

FreeWPC only replaces your game ROM (the U6 chip on the CPU board), which contains all
of the game code and dot matrix text/graphics.  In particular, sounds and
music are NOT included in this device, so FreeWPC games use the
same sounds as the real machines.

FreeWPC is 100% Williams-free code, written from scratch.  It is not a hack on existing
ROMs and does not contain any software extracted from real games.
Most of the code is written mostly in the C programming language.  (Actual WPC games
were programmed in assembly language).  FreeWPC uses the freely available GCC6809 C
compiler.  There are some assembly language routines for really low-level, or high
performance parts of the program.

All generations of WPC are supported.  FreeWPC is also architected into a number of
distinct layers which makes it highly portable to other
types of pinball machines than just WPC games, including new custom hardware.  The
@emph{platform} files describe the circuit boards.  The @emph{CPU} files are specific to
the microprocessor, and can be shared between platforms (WPC and WhiteStar both use
a 6809).  The @emph{machine} files are unique to a particular game.

Development requires a UNIX-like environment, such as Linux or Cygwin for Microsoft Windows
users.  Many common UNIX tools like @command{bc} and @command{perl} are required.

In addition to building ROMs, the toolkit supports @dfn{native mode compilation}, which
builds an executable that can be run directly on your development machine.  This lets you
test and debug the software without requiring a real machine or even an emulator.  Basically,
native mode replaces the lowest level of hardware access with builtin emulation.  Native
mode currently uses the @command{ncurses} terminal library for visualizing the state of the game.

@node Installation
@chapter Installation

This chapter explains how to install the software.

FreeWPC is mainly a toolkit, and thus is provided in source code format.
However, periodically binary ROMs are compiled and published as well.
If you are not a developer, but would like to experiment with FreeWPC,
you can just download the binary packages and install them in your
machine or in your emulator.

If you are a developer and want to write your own game code, for one
of the existing games that FreeWPC has been ported to or for a brand
new game, you need a source code package.

If you just want to browse the source code, you can view it online
at the GitHub repository.

@section Binary Packages

Binary packages are available as @file{.zip} files, which contain
@file{.rom} files.  These ROMs replace the game ROM only (the U6 chip
on the CPU board).  If you want to test in a real machine, you need
to burn a real EPROM from this file.

If you want to test under PinMAME, you need to copy the ROM file into
your PinMAME @file{roms} directory; where this is
depends on how you installed PinMAME.  These directories typically contain
@file{.zip} files of both the game ROM and sound ROMs together.
You'll need to unzip the original file, replace the game ROM, then zip it back.
Make sure to save your original
game ROM file for when you want to revert back to the Williams code.

@section Source Code Packages

The following is a partial list of other programs which are used during the
build process: gcc6809, dd, bc, zip, unzip, bash, Perl.

@section Directory Layout

The FreeWPC source code tree is organized into the following directories:

@table @file

@item kernel/

The core pinball APIs.  All of these functions are kept in the fixed
region of ROM and can be called at any time.

@item common/

Secondary pinball APIs, also called the @dfn{Common Pinball Library}.
These functions are not in fixed ROM and require bank switching to call.

@item machine/@var{machine}/

The machine-specific files.

@item platform/@var{platform}/

The platform-specific files.  These are mostly used during initialization.

@item cpu/@var{cpu}/

The CPU-specific files.  These are mostly assembly language files.

@item fonts/

The standard font files.

@item drivers/

Driver templates for things like jets, slings, kickbacks, etc.

@item include/

All of the include files are kept in here or one of its subdirectories.

@end table

@node Compiling
@chapter Compiling

@section Configuration

FreeWPC can be compiled in many different ways with lots of optional features.
You cannot just type @command{make} at the top of the directory tree without
first specifying what you want to build.  This is done by creating a file
named @file{.config}.  The file @file{config.example} is provided as an
example of the kinds of things that can be tuned.

@file{.config} is written in standard Makefile syntax.  (The top-level
Makefile includes this file.)  You set various options by writing
variable assignments, such as:

@example
MACHINE := wcs
@end example

A list of all of the options is given later in an appendix.
TBD - move the appendix information here.

You must specify at least a @var{MACHINE}.  All other configuration
variables are optional; suitable defaults will be used.

@section Making the ROM

To compile, just run @command{make}.  This will build a ROM and optionally
install it into your PinMAME ROM directory if you have said where that is.

The exact commands are not printed, but you can force the details to be
shown by setting the environment variable @var{Q} to the empty string, like
this:

@example
make Q=""
@end example

The build procedure is complicated, but it can be broken down into the
following steps:

@enumerate

@item Create Blank File

If the size of the ROM is larger than the number of pages that
the compiler generates, then the final ROM image must be
padded with blank sections.  The @command{dd} command is used
to generate a file named @file{blank@var{xxx}.bin}, where @var{xxx}
is the size of the file in kilobytes (KB).  This file
is later concatenated with the linker output to produce
a final ROM of the required size.

@item Create Linker Command Files

The linker is invoked several times, once per page or
bank of ROM.  Different options are passed each time
to place the correct object files into that section, and
to resolve references correctly.  All of these options
are written to linker command files, which have the .lnk
extension and are placed in the @file{build} directory.
They are an essentially a list of command-line options to the linker,
but placed into a file because of the huge number of them.

@item Setting the Machine Symbolic Links

The symbol link @file{mach} is set to point to the correct
machine code directory, based on the value of the MACHINE
make variable.  Likewise, @file{include/mach} is pointed to the
machine includes.

@item Generating Defines

Some #defines are generated automatically by scanning the
code for their uses.  These include files begin with the prefix
@command{gendefine} and are created by a script also named
@command{gendefine} in the @file{tools} directory.

At present this is only used to autogenerate the task group IDs.

@item Generating Callsets

Callsets are a mechanism for implementing a simple
event subscription/invocation mechanism that is fully
described at compile-time.  Event handling code is
emitted in a C file named @file{callset.c}.

@item Compiling and Assembling Source Code

Source code is compiled using the GCC6809 compiler.
The compiler generates assembler code with the @file{.s}
extension.  These files are then assembled using the
asxxxx asembler tools into object files with the @file{.o}
extension.

@item Compiling Page Headers
Because the linker requires each section to contain at
least one object file, a dummy file is assembly per
section to ensure that this doesn't happen.  The page
header is 1 byte long and contains the page number.

@item Linking Pages

The aslink utility is used to create one S-record file,
with the @file{.s19} extension, for each page of ROM.

@item Converting Pages to Binary

The @file{tools/srec2bin} utility included with FreeWPC
is run to convert the S-records into raw binary files.

@item Concatenating Pages

The binary files are concatenated, along with any blank
files, to form the final ROM image.

@end enumerate

@section Build Results

If successful, @file{build/@var{var}.rom} will contain the ready-to-burn ROM image.  @var{var} is
a string composed of the machine's short name and the version number.

Warnings and errors during the build are display on the console as they
occur; they are also log to a file named @file{err}.

In native mode, instead of a ROM, a file named @file{freewpc_@var{var}} is placed at the root
of the tree.

@c ======================================================
@node The WPC Hardware
@chapter The WPC Hardware

@include hardware.texi

@c ======================================================
@node Software Environment
@chapter Software Environment

FreeWPC is a standalone operating system environment.  It does not use any
existing OS and has its own multitasker, memory manager, etc.  This chapter
describes the key features of the OS.

Note: If you are compiling in native mode, most of these functions are
replaced by functions in the host operating system.

@section Multitasking

FreeWPC implements a runtime, round-robin, non-preemptive task scheduler.
The system manages multiple tasks, each of which has its own call stack.  You
can create a new task when you want to run some code in parallel with the current
thread of execution.  The current task has complete control of the CPU and will
continue to run until it explicit exits or sleeps (waiting for a certain amount
of time).  The minimum sleep time is defined by IRQS_PER_TICK and is currently 16ms.

If a task does not give up control, either by sleeping, exiting, or yielding
after a certain amount of time, the fatal error @code{ERR_FCFS_LOCKUP} will be asserted.

Each task is identified by a @dfn{process ID}, or @dfn{pid}.  The PID for a task
is assigned by the system when it is created.  A task also has a @dfn{group ID},
or @dfn{gid}.  The GID is assigned by the programmer, and multiple tasks can share
the same GID.  GIDs allow you to control a group of related tasks, or to
refer to a task using a compile-time ID as opposed to a run-time ID.

In native mode, the multitasking APIs are emulated using the GNU
Pth library.  A good description of this library can be found at:
@url{http://www.gnu.org/pth/}.


@section Real-Time Processing

The multitasking APIs are flexible but do not guarantee realtime response, since
any task may run for a long time.  Processing that needs to occur at a strict interval
is done by @dfn{real time tasks}, sometimes abbreviated in the code as @dfn{RTTs}.

Real-time tasks are scheduled at @emph{compile-time}.  When you write an RTT, you
must also add an entry to the @dfn{schedule file}, either @file{kernel/system.sched}
for the core parts of the system, or @file{machine/@var{machine}/@var{machine}.sched}
for the game-specific RTTs.  Each entry in the schedule file gives the rate at which
you want your function to be run, for example, once every 8ms.  You can schedule
to run as frequently as once every 1ms, but you should only schedule as often as
you really need it, otherwise the CPU will have little time to do anything else!

Real-time functions run at interrupt (IRQ) level.  They will interrupt anything
else that is running at non-real-time priority.

A schedule, @command{gensched}, processes these files at compile-time and generates
the IRQ handler which calls all of the RTTs at the correct frequency.  The output
can be seen in @file{build/sched_irq.c}.

In native mode, realtime functions are run inside an ordinary task.  They
cannot run exactly at the desired rate, but the emulation does its best.

@section Memory Allocation

FreeWPC does not use dynamic (heap) memory allocation at all.  All variables are either
global or on the stack.

Global variables cannot be statically initialized.  Variables should be initialized
explicitly inside a C function.

Global variables can be divided into a number of categories, depending on their
usage.  Normal globals are always in scope and behave as you would expect.  Additionally,
you can tag a global with one of the following attributes:

@table @code

@item __fastram__

Used for variables that are used frequently.  GCC6809 will generate faster
code when accessing these.  However, you are limited to about 250 bytes of
fastram variables total.

@item __permanent__

Used for variables that should be persistent across reboots.  These variables
should be initialized inside of a @code{factory_reset} event, because factory
reset should restore everything to a sane state.

@item __nvram__

Like __permanent__, but for variables that are also write-protected by default.
To modify such a variable, you must first issue an @code{unlock()} call, and
also issue a @code{lock()} call when you are done.  This helps to ensure that
certain critical variables are not accidentally corrupted.

Adjustments and audits kept in NVRAM are managed via special APIs which
do the locking/unlocking for you.

@item __local__

Used for variables that are maintained separately for different players
in a multiplayer game.  The system software will transparently reload
these variables with the correct values whenever the player up changes.
These variables should be initialized inside of an @code{add_player} event.

@end table

@section Event Handling

FreeWPC is mostly an @dfn{event-driven} system, which only acts when there are new
inputs to the system.  This section describes the basic interface to the
application layer software, and then explains how that is implemented internally.

When any module wants to be notified when a particular event occurs, it declares
an event catcher function, using the CALLSET_ENTRY macro.  Here is an example:

@example
CALLSET_ENTRY (strobe_multiball, sw_forcefield_target)
@{
	...
@}
@end example

This declares a new catcher for the module named @code{strobe_multiball},
which is to be called whenever the event @code{sw_forcefield_target} occurs.

The name of the module is arbitrary, but the convention is to use the name
of the source code file or something similar.  The event name must be an
exact match.  There is a list of predefined event names which can be used.
Also, any switch closure can be used as an event name; the names of these
events are declared in the machine configuration file.

If there are multiple catchers for the same event, then all of them
will be invoked, in some random order.  For example, another mode might
also make use of the same targets:

@example
CALLSET_ENTRY (mode_start, sw_forcefield_target)
@{
	...
@}
@end example

Then both of them would be called when the switch is closed.

To generate an event, use the @code{callset_invoke()} API, passing
it the name of the event.  You can create your own events for any
purpose; event names do not need to be declared.  Such events are
as full-featured as system-defined events.  When defining events
in a game, it is customary to prefix the event name with the short
name of the game (e.g. @samp{tz}).

Event catchers are allowed to throw new events.  This will result
in nested function calls.

@subsection Boolean Events

Most event handlers do not return a value.  However, in some cases
it is desirable to stop calling event handlers once the event has
been @emph{claimed}.  You can do this with boolean events.

To throw a boolean event, use @code{callset_invoke_boolean()}.  This
returns TRUE if all of the event handlers return TRUE; else it
returns FALSE.

The event handlers are declared using @code{CALLSET_BOOL_ENTRY} instead
of @code{CALLSET_ENTRY}, and they must return either TRUE or FALSE.

The invocation of boolean handlers will immediately stop if one of them
returns FALSE (so-called @dfn{short-circuit evaluation}).

@subsection Handlers in Banked Pages

Because handlers are invoked via function calls, if the handlers are
in a banked section of ROM, care must be taken to ensure that the
proper far call is made to it.  In most cases, this is autodetected
based on the directory in which the source file is located:

@itemize @bullet
@end itemize

You can explicitly declare the section in the source file by
adding a comment like this:

@example
/* CALLSET_SECTION (@var{module-name}, @var{section-name}) */
@end example

This is only needed if the module uses event handlers.  @var{section-name}
would be something like @code{__common__} or @code{__machine__}.  The
@var{module-name} must match all of the module names used in the
@code{CALLSET_ENTRY} definitions within it.

@subsection Debugging Event Handlers

@command{gencallset} has a @option{-d} option which emits @code{dbprintf()} statements
as each event handler is called.  It is extremely verbose, but it can be used to
debug when you don't know where to start when something isn't working.

You can enable it by setting @command{CALLSET_FLAGS := -d} in @file{.config}.

@section Template Drivers

A @dfn{template} is a crude implementation of a reusable code block, similar in
purpose to C++ templates but much more limited.  Were FreeWPC written in C++,
regular templates would have been used here.

Templates end in @file{.ct} (for C template) and are always kept in the
@file{drivers/} directory.  A template file is @dfn{instantiated} via
commands in the machine description.  The script @command{ctemp} converts
a template to one or more .c or .h files, which are then compiled normally.
Thus, templates can contain RTTs or event handlers just like any other file.

@subsection Template Syntax

A template contains ordinary C code, plus special @dfn{template directives}.  These
always begin with two at-signs (@@@@).  The list of valid directives, in the order
that they are normally used, is listed below:

@table @code

@item @@@@class

Gives the name of the template; usually this is related to the filename.

@item @@@@parameter @var{name}

Declares a template parameter.  The value is substituted during instantiation.

@item @@@@file

Sets the current output filename.  A template can generate any number of output files.
You can switch between the different output files with this directive.

@item @@@@

A template comment.  Used to insert a comment line that is not placed into the current
output file.

@end table

Within the C code, you use single-at (@@) references to substitute the values of
template variables into the text.  For example,

@example
@@@@class xyz
int @@class_variable
@end example

would be translated into the following plain C code:

@example
int xyz_variable
@end example

Notice that template variables cannot contain underscores.

Anything template parameter defined with @@@@parameter can be substituted this way.
Also, the following variables are predefined by the code generator:

@table @code

@item @@class

The name of the template, as given in a @@@@class directive.

@item @@self

The name of the instance.  If a template is instantiated multiple times, each should have
a different name.  For example, the @samp{sling} class might have instances named
@samp{left_sling} and @samp{right_sling}.

@item @@instance

Like @@self, but a zero-based ID.  These are assigned by the code generator during
instantiation.

@end table

@section Fault Detection

Fatal errors when detected will cause the system to reboot.  The system
API @code{fatal()} can be used to cause a fatal error at any time.  A list of the
error codes is kept in @file{include/sys/errno.h}.

There is also the @code{nonfatal()} API
for logging errors which will not cause a reset.  These are audited and when @code{DEBUGGER}
is defined, it will display a brief message on the DMD.

@c ======================================================
@node Hardware APIs
@chapter Hardware APIs

The kernel provides a common set of hardware access functions
that work across all of the different variations of the WPC
architecture.

There are basically two types of APIs.  The low-level APIs
access the hardware directly.  These APIs all begin with @code{pinio}.
They could be ported to any new pinball platform.  These are
normally called only from realtime tasks (driver space, if you will).
Every supported platform (WPC, Whitestar) needs to define these functions.
See @file{include/platform/wpc.h}.

The high-level APIs are invoked from the application layer (user space).  They
are typically more user friendly, and don't actually talk directly to the
hardware, but rather interface with the low-level device driver.

@section Switches

The switch matrix driver polls the hardware every 2ms and constantly updates
its view of all of the switches in memory.  The user APIs can then query this
data.

Less frequently, the driver will also detect when switches have @emph{changed state}
and invoke event handlers for these.

It also performs debouncing so that rapid open and close are not considered.

@table @code

@item pinio_write_switch_column

Set the current switch matrix column.

@item pinio_read_switch_rows

Read all of the switches on the currently selected column.

@item pinio_read_dedicated_switches

Read all of the dedicated switches.

@item pinio_read_flippers
@item pinio_read_flipper_buttons
@item pinio_read_flipper_eos

Read all or some of the flipper switches.

@item pinio_read_locale

@item switch_poll

Read the stable, physical state of a switch.  Returns 1 if it has
a high level, or 0 for a low level.

@item switch_poll_logical

Read the stable, logical state of a switch.  Returns 1 if it is
active, or 0 for inactive.  This is the same as @code{switch_poll}
but it inverts its result for optos.

@end table

@section Lamps

Each physical lamp is controlled by several flags.  The lamp driver
combines the values of all these flags to decide at any time whether
a lamp should be on or off.

@table @asis
@item On/Off
Controls the steady on/off state of the lamp.
@item Flashing
When set, overrides the steady state and causes the lamp to flash.
@item Effect 1 Allocated/Value
When the allocated flag is set, overrides the steady/flashing state
by the value of value flag.
@item Effect 2 Allocated/Value
Same, except overrides the Effect 1 flags as well.
@end table

The steady and flashing flags are per-player, and are automatically
switched out in a multiplayer game.

@table @code
@item lamp_on
Turns on a lamp.
@item lamp_off
Turns off a lamp.
@item lamp_test
Tests whether a lamp is on/off.
@item lamp_toggle
Toggles a lamp's on/off state.
@item lamp_flash_on
Enable lamp flashing.
@item lamp_flash_off
Disable lamp flashing.
@item lamp_flash_toggle
Toggle lamp flashing.
@item lamp_tristate_on
Ensure the lamp is steady.
@item lamp_tristate_off
Ensure the lamp is off.
@item lamp_tristate_flash
Ensure the lamp is flashing.
@item pinio_write_lamp_strobe
Set the current lamp matrix strobe.
@item pinio_write_lamp_data
Write lamp row data for the currently selected column.
@end table

@section Power Drivers

Solenoid outputs are not matrixed; they are individually writable at all times.
A '1' value means to turn it on, and '0' to turn it off.

@table @code
@item pinio_write_solenoid_set (@var{bank}, @var{value})
Refresh a set of 8 solenoids.
@item pinio_read_ac_zerocross
Return nonzero if currently at a zerocross point.
@end table

@subsection Pulse Drivers

@dfn{Pulse drivers} are operated infrequently, and only for short
durations at a time.  The system prevents multiple pulses from
occurring simultaneously and will queue and stage them.  These
are normally used for kickers, poppers, etc.

@table @code
@item sol_request
@end table

@subsection Continuous Drivers

@dfn{Continuous drivers} can run for longer periods of times.
They are allowed to run in parallel with anything else.  They
will frequently use @dfn{duty cycling} to avoid keeping the
coil 100% active for too long, and thus they often require
realtime processing to switch reliably.

These types of drivers are all implemented using templates.

@c include coil-drivers.txt

@subsection Flashers

The flashlamp APIs are similar to the solenoid APIs,
except that they are momentary.  A flashlamp is
pulsed briefly, after which it is turned off.

@table @code
@item flasher_pulse
@end table

@section Zerocross Detector

The zero cross driver increments a counter every 1ms, and clears it
whenever zero cross is asserted.  With knowledge of the AC cycle
length, this allows a relatively good reconstruction of the waveform.
For example, in the US zero cross should occur about once every 8ms.
When the counter is at 4, the AC should be at its peak voltage.
Outside the US, this would occur when the counter is at 5.

Note that the AC waveform is not synchronized to the oscillator that
generates IRQ, so a perfect reconstruction is not possible.

@section Dot-Matrix Display (DMD)

@table @code
@item bmp_draw
@item dmd_alloc_@var{map}
@item dmd_alloc_low_high
@item dmd_and_page
@item dmd_clean_page_@var{map}
@item dmd_copy_page
@item dmd_flip_low_high
@item dmd_or_page
@item dmd_shadow_copy
@item dmd_text_raise
@item dmd_show_@var{map}
@item dmd_show_other
@item dmd_show2
@item dmd_xor_page
@item font_render_string
@item font_render_string_center
@item font_render_string_right
@item frame_draw
@item wpc_dmd_set_high_page
@item wpc_dmd_get_high_page
@item wpc_dmd_set_low_page
@item wpc_dmd_get_low_page
@end table

There are many more APIs for drawing text and graphics.

@section Sound Board

Two flavors of sound board are supported: WPC, and DCS.
The same APIs are used in either case.

@table @code
@item pinio_reset_sound
@item pinio_write_sound
@item pinio_sound_ready_p
@item pinio_read_sound
@item sound_send
Sends any command to the sound board.
@item sound_start
@end table

@section Triacs and General Illumination

@table @code
@item pinio_write_triac
@item triac_on
Turns on one or more triacs.
@item gi_dim
Enables a dim general illumination string.
@item triac_off
Turns off one or more triacs.
@end table

@section Real-Time Clock

The WPC ASIC contains an internal realtime clock.
The battery power keeps the RTC running even when the machine is turned off.

The chip provides three registers for counting minutes, hours, and days.
FreeWPC keeps the calendar time in persistent memory.
About once per minute, it polls the RTC and updates the calendar time to reflect
any changes.

@table @code
@item rtc_read
@item rtc_write
@end table

@section High Precision Timer

@table @code
@item pinio_read_timer
@item pinio_write_timer
@end table

@section Miscellaneous

@table @code
@item pinio_watchdog_reset
@item pinio_active_led_toggle
@end table

@section Debug Port

@section Paging and Locking

@section Bit Shifting

The ASIC has a builtin shifter that can do some bitwise math faster than native 6809 code.

@command{gcc6809} has an option @option{-mwpc} which
enables emitting instructions for the WPC platform.
In some cases, the hardware shifter will be used
automatically.  Note that gcc is unaware of the
threading/interrupt model, so access to the shifter
is not protected.  In the current implementation,
the shifter is not used from the IRQ, and since
tasks are nonpreemptive, that is no problem.

@c ======================================================
@node Effects
@chapter Effects

Effect processing is a layer above the hardware which provides
controlled access to the lamps, display, flashers, and general
illumination.  It resolves contention when multiple tasks try to
access the same object at the same time through the use of
priorities.

The system manages two distinct types of effects: display and
lamp effects.  They always run independently; thus it is not possible
to guarantee allocation of both at the same time.  Lamp effects
manage both the regular lamps, plus the GI and flashers.

@section Basic Effect Principles

These principles apply to both display and lamp effects.

At any time, there is at most 1 effect that is @emph{running}.  The
running effect is the one which has been @emph{started} with the
highest priority.  Priorities are simple integer values:
the higher the number, the more important the effect is.

It is possible for no effect to be running if none has been started.
In that case, the current priority is considered to be zero.  Actual
effects always have a priority that is non-zero.

The running effect is executed in a separate task context.  The
currently running display effect always has the group ID
@code{GID_DEFF}; likewise @code{GID_LEFF} for the lamps.

These tasks can be preempted, if a higher priority effect is started.
In that case, the old task is killed, and a new task is started.

Effects must be declared in the machine configuration file.  Each
entry gives the entry point to the effect, along with its priority
and other optional properties.

The APIs and implementation for display/lamp effects are mostly the
same, but there are differences due to the following:

@itemize @bullet
@item The lamp matrix can be suballocated; the display can only be
allocated as a whole.
@item Some display effects are long-lived, while others are only
temporary.
@item Some display effects do not have high priority, but we should
retry to start it later if possible.
@end itemize

@section Background Effects

The display and music should always be doing something, even when
nothing really important is happening.  Thus, these effect modules
implement @dfn{background effects}, a way to determine what to do
in these circumstances.  Lamp effects do not support a background mode,
because in that case the lamp matrix is best left alone.

The strategy for handling background effects is as follows:  When
no effect has been explicitly started, an event is generated:
@code{display_update} or @code{music_refresh}.  Any module that can
provide a background effect should implement these handlers.

The function can decide which effect, if any, it wants to run by
calling either @code{deff_start_bg} or @code{music_request}.  It passes
the code for the deff or music plus a priority value.  After all of the
event handlers have been invoked, the one with the highest priority
will be started.

The common code provides many of the implementations to deal with the
usual cases.  For example, while a game is running, the default effect
is to show the game scores.  Default music codes can be defined for
different circumstances: normal game play, ball at plunger, during bonus.

Because handlers can use the values of other variables in the
determination (are we in game, for example?), the calculations need to
be redone periodically.  APIs exist to force a refresh: @code{deff_update}
and @code{music_update}.  The system will also invoke them occasionally,
on the order of a few times per second.

@section Display Effects

@table @code
@item deff_start
@item deff_stop
@item deff_exit
@end table

@section Lamp Effects

@table @code
@item leff_start
@item leff_stop
@item leff_exit
@end table

@section Lamplists

Typically, groups of lamps are often used for a
similar purpose.  A lampset is a just of set of
lamps that are often controlled together.  Each
lampset has a unique ID, and is internally
represented by an array of lamp values, terminated
by a special lamp code named @code{LAMP_END}.

The lampset APIs provide convenience whenever
many lamps need to be updated at once.

@section DMD Transitions

A transition is an interim effect that runs between
the end of one display effect and the beginning of
another.  By default, a new effect will simply kill
the old one and overwrite it with a new image.

Transitions are scheduled -- a handler is installed
that runs the next time that a new image is shown.
Instead of showing the image right away, the transition
handler kicks in and displays some combination of
the present view and the new one.  When the transition
finishes, the display should consist entirely of the
new image.

Currently all transitions are contained in @file{common/dmdtrans.c}.

@c ======================================================
@node Ball Tracking
@chapter Ball Tracking

The ball tracking module keeps track of where all of the pinballs are in
the machine.  It is implemented in @file{common/device.c} and uses
container declarations in the machine description.

A @dfn{device} is defined to be something which can hold and release pinballs.
(Earlier versions of the software used the term @emph{container}.)
A device is comprised of one or more switches which count the number of balls
in the device, plus a release solenoid that can be pulsed to force one
ball to be removed.

Ball troughs, kickouts, poppers, saucers, and locks are all just different
shapes that a device can take.  Some containers only hold one ball, while
others can hold many.

@section Device Status

For each device, the ball tracker maintains the following state information:

@itemize @bullet
@item The maximum number of balls it can hold (constant)
@item The current number of balls it has
@item The desired number of balls
@item Whether or not it is in the process of trying to release a ball
@end itemize

The @dfn{desired count} is crucial to understanding the module's behavior.
Whenever it has more balls than desired, it will initiate one or more releases
to try to bring the count down to the desired number.  Otherwise, any balls
that enter the device are kept there; this is used to implement ball locks.

Software requests to kick a ball are @emph{always} done by manipulating the
desired count.  The device module has complete control over the actual
release solenoid.

The trough device is the only device which normally desires to keep any balls.
Playfield devices generally want zero balls unless a lock has been enabled.

Device switches msut be declared as @emph{edge} switches, which invoke the
event handler on both open and close transitions.  The tracker simply updates
the current count on either type of transition.

@section Global Status

The ball tracker also maintains a count of the number of balls in play,
which is the total number of balls installed, minus the number of balls
that are seen in devices, minus the number of balls declared "missing".
Missing balls are flagged when a game is started but the balls are not
all seen.

@section Events

The ball tracker also generates new per-device events.  The name of
the event includes the name of the device: for example,
@code{dev_trough_enter}.

The @dfn{enter} event is generated when the current count goes up by 1.
Game code should normally always register handlers for the enter events
rather than individual switches.  Note that a switch closure does not
always indicate enter: consider an eject that is trying to kick out
but the kicker is weak, so that the ball falls back in immediately.
Also, when a ball trough releases a ball, a whole series of switch
closures occur rapidly.

The @dfn{exit} event is generated when a release is deemed successful.
It happens after a release cycle, when the count goes down by 1.

There are also some useful global events.  @code{single_ball_play}
is generated when the total number of balls in play is reduced to 1,
as at the end of multiball.  Multiball modes use this to exit.
There is also @code{ball_count_change} invoked on every change of
the number of balls in play.

@section The Trough Device

The trough device is special; every game must have one.  The system
completely handles the device events generated for the ball trough.
The function @code{device_add_live} is called whenever a new ball
is added to play.

Likewise, @code{device_remove_live} is called whenever a ball drains.
It ultimately is the one that generates the @code{end_ball} event
when all balls have drained.

@c ======================================================
@node Test Mode
@chapter Test Mode

The FreeWPC test mode works similarly to the original menu system.
However, there are extra options and a few important differences.
For testing core changes to FreeWPC, it is often more convenient to use
test mode than to play a game.

When compiling with the @code{MACHINE_TEST_ONLY} option, the game
will boot directly into test mode, and there is no provision to start a game.

@section Adjustments

All of the @emph{standard adjustments} are supported.  There are also a few
new adjustments.

@subsection Timed Game

This adjustment allows you to switch between normal game play and a timed
game.  Machines can implement different rules for timed play or not.
They can also disable it entirely.

@subsection Switch Stress Test

The switch stress test is used to test switch handling over a long
period of time.  When enabled, this adjustment causes the game to
pretend that switch closures are occurring randomly after the ball
has been plunged into play.  You can force end-of-ball by putting
the ball into the drain.  You can also park the ball somewhere and
the machine will continue to simulate closures indefinitely.

Closures are simulated randomly at a rate of about 10 per second.
This test has been used to uncover some hard to find bugs in the game
logic after extended play.

Naturally, this feature is disabled by default.

@section Audits

All of the @emph{standard audits} are supported.

Presently, audits are kept as 16-bit integers, so they max out at 65535.

@section Tests

The test menu contains roughly the same tests as in the actual WPC
games, with some differences.

@subsection Solenoid Test

@section Development

The development menu contains a series of additional tests that are
probably only relevant to developers and not to end users.

@subsection Font Test

Cycles through all of the available fonts.  Use the flipper buttons
to scroll through the alphabet.  The machine will try to display
as much as possible at once, depending on the font size.

@subsection Display Effect Test

Cycles through all display effects.  Press ENTER to activate a deff,
as if @code{deff_start} were called.  For long-running effects, press
ENTER again to stop it via @code{deff_stop}.

@subsection Lamp Effect Test

Cycles through all lamp effects.  Press ENTER to activate a leff,
as if @code{leff_start} were called.  Press ENTER again to stop it.

Remember that multiple lamp effects can be active simultaneously if
they are declared as shared and they do not overlap in the lamps that
they use.

@subsection Lamplist Test

Cycles through the lamplists.  The flipper buttons cycle through the
different ways that the lamplist can be controlled.  The default is
to turn on all of the lamps.  You can also strobe them, flash them, etc.

@subsection Ball Device Test

Cycles through each of the ball devices, telling you its current status
(how many balls it sees, kickouts pending, errors).  The flipper buttons
will scroll through a set of actions (empty, kick 1, etc.); press ENTER
to perform the action displayed.

This test also continuously shows the global device status, such as
how many total balls are detected and whether any balls are missing.

@subsection Random Test

Tests the random number generator.

@subsection Transition Test

Cycles through all of the dot-matrix transition effects.

@subsection Frame Test

Cycles through all of the display frames.

@subsection Force Error Test

Entering this test forces a fatal error, which should restart the system.

@subsection Display Stress Test

Starts randomly starting and stopping display effects until exiting the test.

@subsection Symbol Test

Cycles through the symbol bitmap, a collection of arrows, boxes, etc.

@subsection Score Test

@subsection PIC Test

Displays vital data about the PIC.

@subsection Memory Editor

Lets you interactively scroll through the CPU's memory and alter values.

@c ======================================================
@node Common Pinball Library
@chapter Common Pinball Library

The files in the @file{common} directory provide a library of generic
pinball functions that can be reused from game to game.  Some of the more
important ones are described in detail in this chapter.

@section Coins and Pricing
@section Ball Devices
@section Extra Balls
@section High Scores
@section Enter Initials
@section Tournament Mode
@section Ball Search
@section Knocker Driver
@section PIC Driver
@section Player Local Data
@section Adjustments
@section Audits
@section Scoring


@c ======================================================
@node Fonts and Graphics
@chapter Fonts and Graphics

This chapter explains how FreeWPC fonts and graphics work.

FreeWPC uses simple bitmaps to represent fonts, icons, and full-screen
graphics.  A @dfn{bitmap} is an array of rectangular pixel data.
The data bits are prefixed by a short header which contains the width
and height information.  The image is stored one row at a time, starting
from the top.  Within a row, the bits are stored in little-endian format,
with the least significant bit representing the leftmost pixel.

A @dfn{font} is a set of bitmaps mapped to a contiguous sequence of
characters.  The font header identifies the ASCII code for the first
bitmap that is represented; this saves space by not needing to encode
the low-valued ASCII control characters.  The nominal height of the
characters is also defined, which allows for descenders.

A @dfn{frame} is a full-screen bitmap, 128x32.  Since these are fairly
common, special APIs are used to draw them that are more optimal, and
the width/height is implied and not actually stored in the bitmap.
A frame can have 4 colors per pixel (3 shades plus back) so
the frame is actually stored as two consecutive @dfn{bit planes}.
Each bit plane also can optionally be compressed using run-length
encoding (RLE) or zero suppression to save space.

@section Compression

Frames can optionally be compressed.  The frame header includes
a flag which indicates the compression method.

@itemize @bullet
@item Run-Length Encoding
@item Zero Suppression
@end itemize

@section Using TrueType Fonts

The script @command{fontgen2} converts TrueType font files (.ttf files)
into WPC font files (.fon).

@section Frame List

The list of all frames compiled in the ROM is defined in an
@dfn{image map}.

@c ======================================================
@node Native Mode
@chapter Native Mode

Native mode lets you run the code directly on your host machine.
It is a form of emulation, like PinMAME, except the emulator is
"built-in" to the game ROM itself.

The main difference in native mode is that all I/O accesses
are emulated.  Calls to @code{readb} and @code{writeb} are
converted to call @code{linux_asic_read} or @code{linux_asic_write},
which does the emulation.

Other features of native mode:

@itemize @bullet

@item You can use GDB to debug the program.

@item printf statements can be used in interrupt handlers.

@item Permanent and NVRAM variables are supported; their values are
saved in files across program runs.  NVRAM variables are not
actually write-protected while the program is running, though.

@end itemize

@c ======================================================
@node Debugging
@chapter Debugging

You can use the @code{dbprintf()} function to print debug
messages.  What happens to these messages depends on how
you compile the code and what emulator you use.

For now, there is no debug support when you are running on
real hardware.

@section @command{wpcdebug} and @command{PinMAME}

PinMAME has been modified to support a new register, the
@dfn{debugger port}.  It acts like a serial port and can
be used to communicate between the running program and a
separate debug console.  The program @command{wpcdebug} is
the console.  Run this at the same time as PinMame and you
will see the debug messages printed out.

You need to be running a patched version of PinMAME under
Linux for this to work.  Under PinMAME for Windows, you
should compile the ROM with the @code{CONFIG_PARALLEL_DEBUG}
option.  This will use the WPC parallel port for all debug
messages.  Standard versions of PinMAME support this, and
will write the output to a file in the @file{nvram} directory.

This virtual port is unlikely any real serial port, in that writes can
be done infinitely fast.  It is an oversimplification but it suffices
for its purpose.

@section @command{gdb}

@section @command{exec09}

exec09 is the 6809 emulator that is provided with GCC6809.
exec09 supports a subset of the WPC architecture and can be used
as a replacement for PinMAME.  It is mostly good for debugging
straight CPU code that does not access hardware.  It provides
a command-line monitor with breakpoints, single-step, and symbolic
debugging which is sometimes more useful than PinMAME or gdb.

@c ======================================================

@c ======================================================
@node The Machine Definition
@appendix The Machine Definition

@include md.texi

@c ======================================================
@node Event Handling
@appendix Event Handling

Here is a list of all of the standard events that the system generates.

@include events.texi

@c ======================================================
@node Build Tools
@appendix Build Tools

@section csum : ROM Checksum Tool

The checksum tool works on FreeWPC ROMs as well as the original
Williams factory ROMs.  It can verify and update the checksum
field located just above the interrupt vector table.

@section srec2bin : S-Record Converter

The gcc6809 linker produces S-record files by default.  This
tool converts S-records to raw binary format.

@section sched : Static Scheduler

The scheduler reads in a list of schedule files, which by
convention end with the extension @file{.sched}.

@section fontgen2 : TrueType Font Generator

@c ======================================================

@include dmd-theory.texi

@node Historical Notes
@appendix Historical Notes

FreeWPC was started in 2005 and was written entirely in assembly language,
before the availability of the gcc6809 C compiler.  An initial attempt
to ease programming involved the use of some complicated macros, written
in the @command{m4} programming language.  Work was halted during the
development of gcc6809, then the system was gradually rewritten in C.
The early source code repository actually contained the compiler changes
as well.

The first time that a FreeWPC ROM was placed into a game was in
May, 2008.  It did not run OK due to some problems with the watchdog
circuit and with the PIC initialization.  Those problems were
resolved within only a few hours.


